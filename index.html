<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Media (Firefox) com Navegação Lateral</title>
    <link id="favicon" rel="icon" href="#">
    <link rel="stylesheet" href="style.css">
    </head>
<body class="initial-load">

<script>
    const THEME_KEY='randomMediaViewerTheme',SPEED_DIAL_CONFIG_KEY='randomMediaSpeedDialConfig';function applyPersistedTheme(){try{const s=localStorage.getItem(THEME_KEY);s==='light'?document.body.classList.add('light-theme'):document.body.classList.remove('light-theme')}catch(s){console.error('Failed to access localStorage for theme:',s)}}applyPersistedTheme();
</script>

<div id="cover-overlay-blur"></div>
<div id="cover-overlay"></div>
<h1 id="main-header-title">Random Media</h1>

<div id="caminho-sidebar">
    <button id="caminho-sidebar-close-btn" title="Fechar Barra Lateral">&times;</button>
    <h3 id="caminho-sidebar-title">Navegação Rápida</h3>
    <ul id="caminho-sidebar-list">
        </ul>
</div>

<div id="speed-dial-container">
    <div id="speed-dial-title">Bem-vindo!</div>
    <div id="lucky-feature-container" style="display: none;">
        <div id="lucky-image-wrapper" style="display: none; cursor: pointer;">
            <img id="lucky-image" src="#" alt="Imagem da sorte">
            <div id="lucky-image-text" style="display: none;"></div>
        </div>
    </div>
    <div id="speed-dial-subtitle">Para começar, selecione a pasta principal "Nucleo" que contém seus arquivos e as subpastas "Caminho".</div>
    <button id="select-nucleo-folder">Selecionar Pasta "Nucleo"</button>
    <div id="speed-dial-status" aria-live="polite"></div>
    <div id="speed-dial-options"></div>
    <input type="file" id="folder-input" webkitdirectory directory multiple>
</div>
<div class="controls-container">
    <button id="return-to-speed-dial">Voltar ao Início</button>
    <div class="search-container">
        <input type="text" id="search-input" placeholder="Pesquisar capas por prefixo..." autocomplete="off" aria-controls="search-suggestions" aria-haspopup="listbox">
        <div id="search-suggestions" role="listbox"></div>
    </div>
    <button id="new-media">Nova Mídia Aleatória</button>
    <button id="theme-toggle-button">Modo Claro/Escuro</button>
</div>
<div id="loading-indicator" aria-live="polite"></div>
<div id="media-container"></div>
<div id="fullscreen-media" onclick="closeFullscreenMedia()">
     <button id="rotate-button" title="Rotacionar" onclick="rotateImage(event)">↻</button>
     <img id="fullscreen-img" src="" alt="Imagem em Tela Cheia" style="display:none;" onclick="event.stopPropagation()">
     <video id="fullscreen-video" controls style="display:none;" onclick="event.stopPropagation()"></video>
</div>

<script>
    'use strict';
    let mediaFiles=[],mediaIndex=new Map(),initialViewHistory=[],sessionViewedPrefixes=new Set(),rotationAngle=0,zoomScale=1,imgOffsetX=0,imgOffsetY=0,isDragging=!1,dragStartX=0,dragStartY=0,dragStartOffsetX=0,dragStartOffsetY=0,isLoading=!1,currentOperationController=null,allSelectedFiles=null,rootDirName='',iconBlobUrls=new Map(),faviconBlobUrl=null,speedDialConfig=[];
    let coverOverlayBlur,coverOverlay,mediaContainerEl,loadingIndicatorEl,newMediaButton,themeToggleButton,speedDialContainerEl,selectNucleoButtonEl,speedDialOptionsEl,speedDialStatusEl,faviconElement,folderInputEl,fullscreenMediaEl,fullscreenImgEl,fullscreenVideoEl,rotateButtonEl,searchInputEl,searchSuggestionsEl,draggedItemOriginalName=null,returnToSpeedDialButton, controlsContainerEl;
    let luckyFeatureContainerEl, luckyImageWrapperEl, luckyImageEl, luckyImageTextEl;
    let mediaIntersectionObserver = null;
    let currentMediaItemsDisplayed = [];
    let previousSuggestionItems = []; // To keep track of items for which blobs were created for suggestions
    let currentLuckyFileItem=null, luckyImageBlobUrl=null, luckyFeatureState='initial';
    let mainHeaderTitleEl; // Variável para o H1 principal

    // Sidebar elements
    let caminhoSidebarEl, caminhoSidebarListEl, caminhoSidebarTitleEl, caminhoSidebarCloseBtnEl;

    const THUMB_ANIM_DELAY_STAGGER=90,COVER_DISPLAY_DELAY=1500,MAX_FILTERED_ITEMS=25,MAX_INITIAL_ITEMS=32,INITIAL_HISTORY_SIZE_LIMIT=MAX_INITIAL_ITEMS*3,ORIGINAIS_FOLDER_NAME='originais',CAPAS_FOLDER_NAME='.capas',CAMINHO_FOLDER_NAMES=Array.from({length:25},(_,i)=>`Caminho ${i+1}`),MAX_SEARCH_SUGGESTIONS=10,MIN_ZOOM=.1,MAX_ZOOM=20,ZOOM_SENSITIVITY=1.1;
    const ICON_NAME_REGEX = /^(icon\d+|fav)\.(jpe?g|png|avif)$/i;

    const delay=(m,s)=>new Promise((r,j)=>{if(s?.aborted)return j(new DOMException('Delay cancelled before start','AbortError'));const l=()=>{clearTimeout(t);j(new DOMException('Delay cancelled','AbortError'))},t=setTimeout(()=>{s?.removeEventListener('abort',l);r()},m);s?.addEventListener('abort',l,{once:!0})});
    function isMediaFile(f){return /\.(jpe?g|png|gif|mp4|mkv|webm|avif)$/i.test(f)}
    function isImageFile(f){return /\.(jpe?g|png|gif|avif)$/i.test(f)}
    function getRandomMedia(m,c){const s=[...m],l=s.length,n=Math.min(c,l);if(n===0)return[];for(let i=l-1;i>=l-n;i--){const k=Math.floor(Math.random()*(i+1));[s[i],s[k]]=[s[k],s[i]]}return s.slice(l-n)}
    function getFirstTwoWords(f){if(!f)return'';const n=f.substring(0,f.lastIndexOf('.'))||f,w=n.split(/[\s_.-]+/).filter(Boolean);return w.slice(0,2).join(' ').trim()||n}
    function revokeItemResources(i){if(!i)return;if(i.blobUrl?.startsWith('blob:')){try{URL.revokeObjectURL(i.blobUrl)}catch(e){}}i.blobUrl=null;i.fileRef=null;i.loadSuccess=null;i.abortController?.abort();i.abortController=null}
    function getRandomInitialMedia(availableFiles,count){if(!availableFiles||availableFiles.length===0)return[];const historySet=new Set(initialViewHistory);let eligibleFiles=availableFiles.filter(f=>f.relativePath&&!historySet.has(f.relativePath));if(eligibleFiles.length===0&&availableFiles.length>0){eligibleFiles=[...availableFiles]}if(eligibleFiles.length===0)return[];const prefixToFileMap=new Map();for(const file of eligibleFiles){if(!file.prefix)continue;if(!prefixToFileMap.has(file.prefix)){prefixToFileMap.set(file.prefix,[])}prefixToFileMap.get(file.prefix).push(file)}if(prefixToFileMap.size===0){const fallbackSelected=getRandomMedia(eligibleFiles,count);const fallbackPaths=fallbackSelected.map(f=>f.relativePath).filter(Boolean);initialViewHistory.unshift(...fallbackPaths);if(initialViewHistory.length>INITIAL_HISTORY_SIZE_LIMIT){initialViewHistory.length=INITIAL_HISTORY_SIZE_LIMIT}for(const file of fallbackSelected){if(file.prefix){sessionViewedPrefixes.add(file.prefix)}}return fallbackSelected}let G_eligiblePrefixes=Array.from(prefixToFileMap.keys());let H_preferredPrefixes=G_eligiblePrefixes.filter(p=>!sessionViewedPrefixes.has(p));let I_prefixesToUseThisRound;if(H_preferredPrefixes.length>0){I_prefixesToUseThisRound=H_preferredPrefixes}else{sessionViewedPrefixes.clear();I_prefixesToUseThisRound=G_eligiblePrefixes}for(let i=I_prefixesToUseThisRound.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[I_prefixesToUseThisRound[i],I_prefixesToUseThisRound[j]]=[I_prefixesToUseThisRound[j],I_prefixesToUseThisRound[i]]}const resultFiles=[];const selectedRelativePathsThisRun=new Set();for(const prefix of I_prefixesToUseThisRound){if(resultFiles.length>=count)break;const filesForThisPrefix=prefixToFileMap.get(prefix);if(filesForThisPrefix&&filesForThisPrefix.length>0){const K_availableFilesInPrefix=filesForThisPrefix.filter(f=>!selectedRelativePathsThisRun.has(f.relativePath));if(K_availableFilesInPrefix.length>0){const L_randomIndex=Math.floor(Math.random()*K_availableFilesInPrefix.length);const M_selectedFile=K_availableFilesInPrefix[L_randomIndex];resultFiles.push(M_selectedFile);selectedRelativePathsThisRun.add(M_selectedFile.relativePath);sessionViewedPrefixes.add(M_selectedFile.prefix)}}}if(resultFiles.length<count){const N_remainingEligibleFiles=eligibleFiles.filter(f=>!selectedRelativePathsThisRun.has(f.relativePath));if(N_remainingEligibleFiles.length>0){const O_neededCount=count-resultFiles.length;const P_additionalFiles=getRandomMedia(N_remainingEligibleFiles,O_neededCount);for(const file of P_additionalFiles){if(resultFiles.length>=count)break;resultFiles.push(file);selectedRelativePathsThisRun.add(file.relativePath);if(file.prefix)sessionViewedPrefixes.add(file.prefix)}}}const Q_resultPaths=resultFiles.map(f=>f.relativePath).filter(Boolean);initialViewHistory.unshift(...Q_resultPaths);if(initialViewHistory.length>INITIAL_HISTORY_SIZE_LIMIT){initialViewHistory.length=INITIAL_HISTORY_SIZE_LIMIT}return resultFiles}
    function setSpeedDialStatus(m,e=!1){if(!speedDialStatusEl)return;speedDialStatusEl.textContent=m;speedDialStatusEl.classList.toggle('error',e)}
    function beginOperation(){if(currentOperationController){currentOperationController.abort()}currentOperationController=new AbortController();isLoading=!0;if(selectNucleoButtonEl)selectNucleoButtonEl.disabled=!0;if(newMediaButton)newMediaButton.disabled=!0;if(themeToggleButton)themeToggleButton.disabled=!0;if(searchInputEl)searchInputEl.disabled=!0;if(returnToSpeedDialButton)returnToSpeedDialButton.disabled=!0;if(speedDialOptionsEl){speedDialOptionsEl.querySelectorAll('.speed-dial-item').forEach(i=>{i.style.pointerEvents='none';i.setAttribute('aria-disabled','true')})}return currentOperationController.signal}
    function endOperation(s=!0){if(!isLoading&&!currentOperationController)return;isLoading=!1;currentOperationController=null;if(selectNucleoButtonEl)selectNucleoButtonEl.disabled=!1;const i=!document.body.classList.contains('initial-load')&&(!speedDialContainerEl||speedDialContainerEl.style.display==='none');if(returnToSpeedDialButton){returnToSpeedDialButton.style.display=i?'inline-block':'none';returnToSpeedDialButton.disabled=!1}if(i){const h=mediaFiles.some(t=>!t.isCoverFile),c=mediaFiles.some(t=>t.isCoverFile);if(searchInputEl)searchInputEl.disabled=!(allSelectedFiles&&c);if(newMediaButton){newMediaButton.style.display=h?'inline-block':'none';newMediaButton.disabled=!h}if(controlsContainerEl) controlsContainerEl.style.display = 'flex';
    }else{if(newMediaButton)newMediaButton.style.display='none';if(searchInputEl)searchInputEl.disabled=!0;if(controlsContainerEl) controlsContainerEl.style.display = 'none'; hideCaminhoSidebar(); 
    }if(themeToggleButton)themeToggleButton.disabled=!1;if(allSelectedFiles&&speedDialOptionsEl){speedDialOptionsEl.querySelectorAll('.speed-dial-item').forEach(t=>{t.style.pointerEvents='auto';t.removeAttribute('aria-disabled')})}}

    function cleanupUIState() {
        clearTimeout(window.coverDisplayTimeoutId || 0);
        if (coverOverlayBlur) { coverOverlayBlur.classList.remove('visible'); coverOverlayBlur.style.backgroundImage = 'none'; }
        if (coverOverlay) { coverOverlay.classList.remove('visible'); coverOverlay.style.backgroundImage = 'none'; }
        if (document.body) document.body.classList.remove('cover-active');
        if (mediaContainerEl) { mediaContainerEl.innerHTML = ''; mediaContainerEl.classList.remove('view-initial', 'view-filtered'); }
        if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
        if (searchSuggestionsEl) { searchSuggestionsEl.innerHTML = ''; searchSuggestionsEl.style.display = 'none'; }
        if (searchInputEl) searchInputEl.value = '';

        if (mediaIntersectionObserver) {
            mediaIntersectionObserver.disconnect();
            mediaIntersectionObserver = null;
        }
        currentMediaItemsDisplayed = [];
        hideCaminhoSidebar();
    }

    function buildMediaIndexSynchronous(signal) { // Renamed from buildMediaIndex
        if (signal?.aborted) throw new DOMException('Index cancelled', 'AbortError');
        // const oldIsLoading = isLoading; // isLoading is managed by beginOperation/endOperation now
        // isLoading = true;
        mediaIndex.clear();
        for (let k = 0; k < mediaFiles.length; k++) {
            if (k % 500 === 0 && signal?.aborted) {
                mediaIndex.clear();
                // isLoading = oldIsLoading;
                throw new DOMException('Index aborted during build (sync)', 'AbortError');
            }
            const fileItem = mediaFiles[k];
            const prefix = fileItem.prefix?.toLowerCase(); // Assuming prefix is already available
            if (!prefix) continue;

            if (!mediaIndex.has(prefix)) {
                mediaIndex.set(prefix, { covers: [], regulars: [] });
            }
            const entry = mediaIndex.get(prefix);
            (fileItem.isCoverFile ? entry.covers : entry.regulars).push(fileItem);
        }
        // isLoading = oldIsLoading;
    }

    function buildMediaIndex(signal) { // New async function using Web Worker
        return new Promise((resolve, reject) => {
            if (signal?.aborted) {
                return reject(new DOMException('Index aborted before start', 'AbortError'));
            }

            if (typeof Worker === 'undefined') {
                console.warn("Web Workers not supported. Building media index on main thread.");
                try {
                    buildMediaIndexSynchronous(signal); // Call the synchronous version
                    resolve(mediaIndex); // Resolve with the globally updated mediaIndex
                } catch (e) {
                    reject(e);
                }
                return;
            }

            const worker = new Worker('media_indexer_worker.js');

            const simplifiedMediaFiles = mediaFiles.map(f => ({
                // Pass only necessary data to the worker
                name: f.name, // Worker might need this if prefix is not pre-calculated
                // relativePath: f.relativePath, // Only if worker needs it for some reason
                isCoverFile: f.isCoverFile,
                prefix: f.prefix // Assuming prefix is calculated on main thread before this
            }));

            worker.postMessage({ files: simplifiedMediaFiles });

            worker.onmessage = function(e) {
                if (e.data.type === 'success') {
                    mediaIndex = e.data.mediaIndex; // Update global mediaIndex
                    resolve(e.data.mediaIndex);
                } else if (e.data.type === 'error') {
                    console.error("Worker error building media index:", e.data.message);
                    reject(new Error(e.data.message));
                } else if (e.data.type === 'abort') {
                    reject(new DOMException('Index aborted by worker', 'AbortError'));
                }
                worker.terminate(); // Clean up worker
            };

            worker.onerror = function(e) {
                console.error("Error with media indexer worker:", e.message, e);
                reject(new Error(`Worker error: ${e.message}`));
                worker.terminate(); // Clean up worker
            };

            if (signal) {
                signal.addEventListener('abort', () => {
                    worker.terminate(); // Terminate the worker on abort signal
                    reject(new DOMException('Index aborted by signal', 'AbortError'));
                }, { once: true });
            }
        });
    }

    async function ensureFileObjectForItem(item, signal) {
        if (signal?.aborted) throw new DOMException('Cancelled during file check', 'AbortError');

        if (item.fileHandle && !(item.fileRef instanceof File)) { // New API path: FileSystemFileHandle needs conversion
            try {
                item.fileRef = await item.fileHandle.getFile();
            } catch (err) {
                console.error(`Error getting File from handle for ${item.name}:`, err);
                item.loadSuccess = false;
                item.type = 'error/access'; // Or a more specific error type
                return false;
            }
        }

        if (item.fileRef instanceof File) { // Common path (legacy or after conversion)
            const extension = item.name.split('.').pop()?.toLowerCase() || '';
            const mimeTypes = {'jpg':'image/jpeg','jpeg':'image/jpeg','png':'image/png','gif':'image/gif','mp4':'video/mp4','webm':'video/webm','mkv':'video/x-matroska','avif':'image/avif'};
            item.type = mimeTypes[extension] || item.fileRef.type || 'application/octet-stream';
            return true;
        } else { // Fallback if fileRef is still not a File object
            item.loadSuccess = false;
            item.type = 'error/missing-ref';
            console.warn(`Missing file reference for item: ${item.name}`);
            return false;
        }
    }

    async function loadBlobForItem(i,s){if(s?.aborted)throw new DOMException('Cancelled before blob load','AbortError');if(i.blobUrl&&i.loadSuccess===!0)return!0;if(i.loadSuccess===!1)return!1;i.abortController?.abort();i.abortController=new AbortController();const t=i.abortController.signal,c=AbortSignal.any?AbortSignal.any([s,t].filter(Boolean)):(s||t);i.loadSuccess='pending';try{if(!await ensureFileObjectForItem(i,c)){i.loadSuccess=!1;return!1}const f=i.fileRef;if(!f)throw new Error("Missing file reference unexpectedly");if(c?.aborted)throw new DOMException('Cancelled before blob creation','AbortError');if(i.blobUrl&&i.blobUrl.startsWith('blob:')){try{URL.revokeObjectURL(i.blobUrl)}catch(e){}}i.blobUrl=URL.createObjectURL(f);if(c?.aborted){URL.revokeObjectURL(i.blobUrl);i.blobUrl=null;throw new DOMException('Cancelled after blob creation','AbortError')}i.loadSuccess=!0;return!0}catch(e){if(e.name==='AbortError'){i.loadSuccess=null;i.blobUrl=null;if(i.blobUrl?.startsWith('blob:'))try{URL.revokeObjectURL(i.blobUrl)}catch(x){}}else{console.error("Error creating blob for",i.name,e);i.loadSuccess=!1;i.blobUrl=null}return!1}finally{i.abortController=null}}
    async function loadCoverImageBlobUrl(i,s){if(s?.aborted)throw new DOMException('Cancelled loading cover blob','AbortError');if(!i?.isCoverFile)return null;try{return await loadBlobForItem(i,s)?i.blobUrl:null}catch(e){if(e.name==='AbortError')throw e;console.error("Non-abort error loading cover blob:",i.name,e);return null}}
    function buildMediaElement(i){if(!i||i.isCoverFile)return null;const d=document.createElement('div');d.className='media-container-item';if(i.isOriginal){d.classList.add('is-original');const l=document.createElement('span');l.className='original-label';l.textContent='Original';d.appendChild(l)}const c=document.createElement('p');c.onclick=e=>{e.stopPropagation();if(!isLoading)displayGlobalMediaByPrefix(i.prefix)};c.title=i.name;let m;if(i.loadSuccess===!0&&i.blobUrl){if(i.type?.startsWith('image')){m=document.createElement('img');m.src=i.blobUrl;m.alt=i.name;m.loading='lazy'}else if(i.type?.startsWith('video')){m=document.createElement('video');m.src=i.blobUrl;m.muted=!0;m.preload='metadata';m.playsInline=!0}if(m){m.className='media-item';m.onclick=e=>{e.stopPropagation();showFullscreenMedia(i.blobUrl,i.type)};m.onerror=()=>{const p=document.createElement('div');p.className='media-error-placeholder';p.textContent='Render Err';if(m.parentNode)m.parentNode.replaceChild(p,m);i.loadSuccess=!1;revokeItemResources(i);c.textContent=`${i.prefix||'?'} (Render Err)`;d.classList.add('has-error')}}}if(!m){m=document.createElement('div');m.className='media-error-placeholder';let e="Erro";switch(i.loadSuccess){case!1:e=i.type==='error/missing-ref'?'No Ref':(i.type==='error/access'?'No Access':'Load Fail');break;case'pending':e='Carregando...';break;case null:e='Not Loaded';break}m.textContent=e;c.textContent=`${i.prefix||'?'} (${e})`;d.classList.add('has-error')}d.appendChild(m);c.textContent=c.textContent||i.prefix||'?';d.appendChild(c);return d}
    async function ensureMediaReadyAndBuildElement(item, signal) {
        if (signal?.aborted) throw new DOMException('Cancelled before ensuring media readiness', 'AbortError');
        if (!item || item.isCoverFile) return null;

        let blobLoadedSuccessfully = false;
        if (!item.blobUrl && item.loadSuccess !== false) {
            try {
                if (await loadBlobForItem(item, signal)) { // This sets item.blobUrl
                    blobLoadedSuccessfully = true;
                }
            } catch (e) {
                if (e.name === 'AbortError') throw e;
                // item.loadSuccess would be false, blobUrl would be null from loadBlobForItem
            }
        } else if (item.blobUrl && item.loadSuccess === true) {
            blobLoadedSuccessfully = true;
        }

        if (signal?.aborted) {
            if (blobLoadedSuccessfully && item.blobUrl) {
                // If we loaded a blob but are now aborting before element creation
                revokeItemResources(item);
            }
            throw new DOMException('Cancelled after trying to load blob', 'AbortError');
        }

        // If blob loading failed earlier, item.loadSuccess will be false.
        // buildMediaElement handles items with item.loadSuccess !== true by showing an error placeholder.
        const element = buildMediaElement(item);
        if (!element && blobLoadedSuccessfully && item.blobUrl) {
            // If element creation failed for some reason AFTER successful blob load
            // (e.g., buildMediaElement had an unexpected issue for a loaded item)
            // This is a safeguard.
            revokeItemResources(item);
        }
        return element;
    }

    async function handleMediaIntersection(entries, observer) {
        for (const entry of entries) {
            if (entry.isIntersecting) {
                const placeholderEl = entry.target;
                observer.unobserve(placeholderEl); // Stop observing this placeholder

                const itemIndex = parseInt(placeholderEl.dataset.mediaArrayIndex, 10);
                if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= currentMediaItemsDisplayed.length) {
                    console.error("Invalid mediaArrayIndex in placeholder:", placeholderEl.dataset.mediaArrayIndex);
                    placeholderEl.remove(); // Remove invalid placeholder
                    continue;
                }

                const mediaItem = currentMediaItemsDisplayed[itemIndex];

                if (mediaItem) {
                    // Use the global currentOperationController's signal if available, otherwise null.
                    const loadSignal = currentOperationController ? currentOperationController.signal : null;
                    if (loadSignal?.aborted) { // Check if the overall operation was cancelled
                        // Don't replace, maybe just mark placeholder as cancelled or remove
                        placeholderEl.textContent = 'Cancelado';
                        return;
                    }

                    const actualMediaElement = await ensureMediaReadyAndBuildElement(mediaItem, loadSignal);

                    if (loadSignal?.aborted && !actualMediaElement) { // If aborted during load
                         placeholderEl.textContent = 'Cancelado';
                         return;
                    }

                    if (actualMediaElement) {
                        // Check if placeholder is still in DOM before replacing
                        if (placeholderEl.parentNode) {
                            placeholderEl.replaceWith(actualMediaElement);
                             // Add class with a slight delay to ensure transition can be seen if any
                            setTimeout(() => actualMediaElement.classList.add('visible'), 5);
                        } else {
                             // Placeholder was removed (e.g. by cleanupUIState), discard the loaded element
                             revokeItemResources(mediaItem); // Clean up blob if created
                        }
                    } else {
                        // Build failed, update placeholder to show error
                        placeholderEl.textContent = 'Erro ao Carregar';
                        placeholderEl.style.height = 'auto';
                        placeholderEl.style.minHeight = '60px'; // Smaller error display
                        placeholderEl.style.display = 'flex';
                        placeholderEl.style.alignItems = 'center';
                        placeholderEl.style.justifyContent = 'center';
                        placeholderEl.classList.add('has-error');
                    }
                } else {
                    console.warn("Media item not found for placeholder, index:", itemIndex);
                    placeholderEl.remove(); // Remove if no corresponding item
                }
            }
        }
    }

    async function displayMedia(mediaItemsToDisplay, signal, isInitialView) {
        if (signal?.aborted) return;
        if (!mediaContainerEl) return;

        currentMediaItemsDisplayed = mediaItemsToDisplay; // Store for IntersectionObserver callback

        mediaContainerEl.innerHTML = '';
        mediaContainerEl.classList.remove('view-initial', 'view-filtered');
        mediaContainerEl.classList.add(isInitialView ? 'view-initial' : 'view-filtered');
        mediaContainerEl.style.display = 'block';

        const regularMediaItems = (mediaItemsToDisplay || []).filter(item => !item.isCoverFile);

        if (regularMediaItems.length === 0) {
            const messageStyle = "text-align: center; width: 100%; column-span: all; padding: 20px 0;";
            if (!document.body.classList.contains('cover-active')) {
                mediaContainerEl.innerHTML = `<p style="${messageStyle}">Nenhum item encontrado para exibir.</p>`;
            }
            return;
        }

        // Setup Intersection Observer
        if (mediaIntersectionObserver) {
            mediaIntersectionObserver.disconnect();
        }
        mediaIntersectionObserver = new IntersectionObserver(handleMediaIntersection, {
            root: null, // viewport
            rootMargin: '300px 0px 300px 0px' // Load when 300px away from viewport
        });

        const batchSize = isInitialView ? MAX_INITIAL_ITEMS : MAX_FILTERED_ITEMS;
        const initialBatch = regularMediaItems.slice(0, batchSize);
        const remainingItemsStartIndex = initialBatch.length;

        let animationDelays = []; // For staggering animation
        const cancelAnimationTimeouts = () => animationDelays.forEach(clearTimeout);
        if(signal) signal.addEventListener('abort', cancelAnimationTimeouts, { once: true });

        const fragment = document.createDocumentFragment();

        // Process initial batch
        const initialElementsPromises = initialBatch.map(item => ensureMediaReadyAndBuildElement(item, signal));
        const settledInitialElements = await Promise.allSettled(initialElementsPromises);

        settledInitialElements.forEach(promiseResult => {
            if (signal?.aborted) return;
            if (promiseResult.status === 'fulfilled' && promiseResult.value) {
                fragment.appendChild(promiseResult.value);
            }
        });

        if (signal?.aborted) {
            // Cleanup resources for items in fragment if aborted before append
            fragment.childNodes.forEach(node => {
                 // This is tricky as node doesn't directly link to mediaItem.
                 // For now, this path might leak some blobs if aborted here.
            });
            return;
        }
        mediaContainerEl.appendChild(fragment);

        // Stagger visibility for initial batch
        Array.from(mediaContainerEl.children).forEach((child, index) => {
            if (index < batchSize) { // Only animate the initial batch
                const timeoutId = setTimeout(() => {
                    if (!signal?.aborted && child.isConnected) {
                        child.classList.add('visible');
                    }
                }, index * THUMB_ANIM_DELAY_STAGGER);
                animationDelays.push(timeoutId);
            }
        });

        // Create placeholders for remaining items
        if (regularMediaItems.length > remainingItemsStartIndex) {
            const placeholderFragment = document.createDocumentFragment();
            for (let i = remainingItemsStartIndex; i < regularMediaItems.length; i++) {
                if (signal?.aborted) break;
                const originalItemIndex = mediaItemsToDisplay.indexOf(regularMediaItems[i]); // Find index in original list

                const placeholderEl = document.createElement('div');
                placeholderEl.className = 'media-placeholder';
                // Store the index from the `mediaItemsToDisplay` array passed to `displayMedia`
                placeholderEl.dataset.mediaArrayIndex = originalItemIndex;
                // Basic styling for placeholder dimensions - can be improved with aspect ratio
                // placeholderEl.style.height = '250px'; // Example fixed height
                placeholderFragment.appendChild(placeholderEl);
                mediaIntersectionObserver.observe(placeholderEl);
            }
            if (!signal?.aborted) {
                 mediaContainerEl.appendChild(placeholderFragment);
            }
        }

        if (signal && !signal.aborted && initialBatch.length === 0 && regularMediaItems.length > 0) {
            // This case means all initial items failed to load or were filtered out before display.
            // If placeholders were added, they will attempt to load.
            // If no placeholders either (e.g. total items < batchSize but all failed), show error.
            if (mediaContainerEl.children.length === 0) { // No initial items, no placeholders
                 const errorStyle = "color:var(--error-text); text-align: center; width: 100%; column-span: all; padding: 20px 0;";
                 mediaContainerEl.innerHTML = `<p style="${errorStyle}">Erro ao carregar itens de mídia iniciais.</p>`;
            }
        }
        if(signal) signal.removeEventListener('abort', cancelAnimationTimeouts);
    }
    
    // Funções para Instagram Link
    function getInstagramUsername(fileName) {
        if (!fileName) return null;
        const match = fileName.match(/@([a-zA-Z0-9_.]+)/);
        return match ? match[1] : null;
    }

    function updateMainHeader(contentOrUsername) {
        if (!mainHeaderTitleEl) mainHeaderTitleEl = document.getElementById('main-header-title');
        if (!mainHeaderTitleEl) return;

        mainHeaderTitleEl.innerHTML = ''; 

        if (contentOrUsername && contentOrUsername.startsWith('@')) {
            const username = contentOrUsername.substring(1);
            const instagramLink = document.createElement('a');
            instagramLink.href = `https://www.instagram.com/${username}/`;
            instagramLink.textContent = 'Instagram';
            instagramLink.target = '_blank';
            instagramLink.rel = 'noopener noreferrer';
            instagramLink.classList.add('instagram-link');
            mainHeaderTitleEl.appendChild(instagramLink);
        } else {
            mainHeaderTitleEl.textContent = contentOrUsername || 'Random Media';
        }
    }

    /*
    async function displayFilteredMedia(p){if(!p||isLoading)return;if(searchInputEl&&searchInputEl.value)searchInputEl.value='';if(searchSuggestionsEl){searchSuggestionsEl.innerHTML='';searchSuggestionsEl.style.display='none'}const s=beginOperation();let c=null;let coverItemName = null; try{
        updateMainHeader('Random Media'); // Reset header
        resetLuckyFeature();if(speedDialContainerEl) speedDialContainerEl.style.display = 'none';
        hideCaminhoSidebar(); 
        clearTimeout(window.coverDisplayTimeoutId||0);if(coverOverlayBlur){coverOverlayBlur.classList.remove('visible');coverOverlayBlur.style.backgroundImage='none'}if(coverOverlay){coverOverlay.classList.remove('visible');coverOverlay.style.backgroundImage='none'}if(document.body)document.body.classList.remove('cover-active');if(loadingIndicatorEl){loadingIndicatorEl.textContent=`Filtrando por "${p}"...`;loadingIndicatorEl.style.display='block'}if(s.aborted)throw new DOMException('Cancelled early','AbortError');const e=mediaIndex.get(p.toLowerCase());if(!e||(!e.regulars?.length&&!e.covers?.length)){console.warn(`Prefix "${p}" not found in index.`);if(mediaContainerEl)mediaContainerEl.style.display='none';if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Prefixo "${p}" não encontrado na pasta selecionada. Tente outro.`,!1);endOperation(!0);return}const o=e.covers||[];let r=e.regulars||[];if(r.length>MAX_FILTERED_ITEMS){r=getRandomMedia(r,MAX_FILTERED_ITEMS)}if(r.length===0){console.warn(`No regular media found for prefix "${p}", only covers or empty regulars list.`);if(coverOverlayBlur){coverOverlayBlur.classList.remove('visible');coverOverlayBlur.style.backgroundImage='none'}if(coverOverlay){coverOverlay.classList.remove('visible');coverOverlay.style.backgroundImage='none'}if(document.body)document.body.classList.remove('cover-active');if(mediaContainerEl){mediaContainerEl.innerHTML='';mediaContainerEl.style.display='none'}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Nenhum item regular encontrado para "${p}" neste Caminho. Selecione outro.`,!1);endOperation(!0);return}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(mediaContainerEl)mediaContainerEl.style.display='block';if(controlsContainerEl)controlsContainerEl.style.display='flex';document.body.classList.remove('initial-load');if(o.length>0){const u=o.filter(i=>i.loadSuccess!==!1);if(u.length>0){const t=u[Math.floor(Math.random()*u.length)];c=await loadCoverImageBlobUrl(t,s); coverItemName = t.name;}}
        
        if (coverItemName) { // Update header if cover is shown
            const username = getInstagramUsername(coverItemName);
            if (username) updateMainHeader('@' + username);
        }

        if(s.aborted)throw new DOMException('Cancelled during cover load','AbortError');if(c){if(coverOverlayBlur){coverOverlayBlur.style.backgroundImage=`url('${c}')`;requestAnimationFrame(()=>{if(!s.aborted)coverOverlayBlur.classList.add('visible')})}if(coverOverlay){coverOverlay.style.backgroundImage=`url('${c}')`;requestAnimationFrame(()=>{if(!s.aborted)coverOverlay.classList.add('visible')})}if(document.body&&!s.aborted)document.body.classList.add('cover-active');window.coverDisplayTimeoutId=setTimeout(async()=>{if(s.aborted)return;try{await displayMedia(r,s,!1);endOperation(!0)}catch(d){if(d.name!=='AbortError'){console.error("Error during post-cover media display:",d);setSpeedDialStatus(`Erro ao exibir mídia para "${p}" após a capa.`,!0)}endOperation(!1)}},COVER_DISPLAY_DELAY)}else{await displayMedia(r,s,!1);endOperation(!0)}}catch(e){if(e.name!=='AbortError'){console.error(`Error filtering for prefix "${p}":`,e);if(mediaContainerEl)mediaContainerEl.style.display='none';if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Erro ao filtrar por "${p}". Verifique o console.`,!0);endOperation(!1)}else{console.log(`Filtering for "${p}" was cancelled.`);if(!isLoading){cleanupUIState();if(speedDialContainerEl)speedDialContainerEl.style.display='flex';if(controlsContainerEl)controlsContainerEl.style.display='none';if(document.body)document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Filtragem por "${p}" cancelada.`,!1);endOperation(!1)}}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(document.body&&!document.body.classList.contains('cover-active')){document.body.classList.remove('cover-active')}}}
    
    async function displayGlobalMediaByPrefix(t){if(!t||isLoading||!allSelectedFiles)return;if(searchInputEl&&searchInputEl.value)searchInputEl.value='';if(searchSuggestionsEl){searchSuggestionsEl.innerHTML='';searchSuggestionsEl.style.display='none'}const s=beginOperation();let g=null;let coverItemName = null; try{
        updateMainHeader('Random Media'); // Reset header
        resetLuckyFeature(); if(speedDialContainerEl) speedDialContainerEl.style.display = 'none';
        clearTimeout(window.coverDisplayTimeoutId||0);if(coverOverlayBlur){coverOverlayBlur.classList.remove('visible');coverOverlayBlur.style.backgroundImage='none'}if(coverOverlay){coverOverlay.classList.remove('visible');coverOverlay.style.backgroundImage='none'}if(document.body)document.body.classList.remove('cover-active');if(loadingIndicatorEl){loadingIndicatorEl.textContent=`Pesquisando por "${t}" em todos os Caminhos...`;loadingIndicatorEl.style.display='block'}if(s.aborted)throw new DOMException('Cancelled early (global search)','AbortError');const o=[],r=[];const a=t.toLowerCase();const b=rootDirName?`${rootDirName}/${CAPAS_FOLDER_NAME}/`:`${CAPAS_FOLDER_NAME}/`;for(const f of allSelectedFiles){if(s.aborted)throw new DOMException('Scan Cancelled during file iteration (global search)','AbortError');const l=f.webkitRelativePath?.replace(/^\.\//,'');if(!l||!isMediaFile(f.name))continue;const p=l.split('/');if(p.length<(rootDirName?2:1))continue;const n=p[p.length-1],h=getFirstTwoWords(n);if(h.toLowerCase()!==a)continue;const k=p.slice(0,-1),S=k.join('/')+(k.length>0?'/':'');let C=!1,R=!1,O=!1;if(S===b){C=!0}else{for(const x of CAMINHO_FOLDER_NAMES){const N=rootDirName?`${rootDirName}/${x}/`:`${x}/`;if(S.startsWith(N)){R=!0;O=k.some(e=>e.toLowerCase()===ORIGINAIS_FOLDER_NAME);break}}}if(C||R){const M={name:n,fileRef:f,relativePath:l,isCoverFile:C,isOriginal:O,prefix:h,blobUrl:null,type:null,loadSuccess:null,abortController:null};if(C){o.push(M)}else if(R){r.push(M)}}}if(r.length===0&&o.length===0){console.warn(`Prefix "${t}" not found anywhere.`);if(mediaContainerEl)mediaContainerEl.style.display='none';if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Prefixo "${t}" não encontrado em nenhum Caminho. Tente outro.`,!1);endOperation(!0);return}let F=r;if(F.length>MAX_FILTERED_ITEMS){F=getRandomMedia(F,MAX_FILTERED_ITEMS)}if(F.length===0){console.warn(`No regular media found globally for prefix "${t}", only covers or empty regulars list.`);if(coverOverlayBlur){coverOverlayBlur.classList.remove('visible');coverOverlayBlur.style.backgroundImage='none'}if(coverOverlay){coverOverlay.classList.remove('visible');coverOverlay.style.backgroundImage='none'}if(document.body)document.body.classList.remove('cover-active');if(mediaContainerEl){mediaContainerEl.innerHTML='';mediaContainerEl.style.display='none'}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Nenhum item regular encontrado para "${t}" em todos os Caminhos. Selecione outro.`,!1);endOperation(!0);return}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(mediaContainerEl)mediaContainerEl.style.display='block';if(controlsContainerEl)controlsContainerEl.style.display='flex';document.body.classList.remove('initial-load');if(o.length>0){const u=o.filter(i=>i.loadSuccess!==!1);if(u.length>0){const m=u[Math.floor(Math.random()*u.length)];g=await loadCoverImageBlobUrl(m,s); coverItemName = m.name;}}
        
        if (coverItemName) { // Update header if cover is shown
            const username = getInstagramUsername(coverItemName);
            if (username) updateMainHeader('@' + username);
        }

        if(s.aborted)throw new DOMException('Cancelled during global cover load','AbortError');if(g){if(coverOverlayBlur){coverOverlayBlur.style.backgroundImage=`url('${g}')`;requestAnimationFrame(()=>{if(!s.aborted)coverOverlayBlur.classList.add('visible')})}if(coverOverlay){coverOverlay.style.backgroundImage=`url('${g}')`;requestAnimationFrame(()=>{if(!s.aborted)coverOverlay.classList.add('visible')})}if(document.body&&!s.aborted)document.body.classList.add('cover-active');window.coverDisplayTimeoutId=setTimeout(async()=>{if(s.aborted)return;try{await displayMedia(F,s,!1);endOperation(!0)}catch(d){if(d.name!=='AbortError'){console.error("Error during post-cover global media display:",d);setSpeedDialStatus(`Erro ao exibir mídia global para "${t}" após a capa.`,!0)}endOperation(!1)}},COVER_DISPLAY_DELAY)}else{await displayMedia(F,s,!1);endOperation(!0)}}catch(e){if(e.name!=='AbortError'){console.error(`Error global filtering for prefix "${t}":`,e);if(mediaContainerEl)mediaContainerEl.style.display='none';if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Erro ao filtrar globalmente por "${t}". Verifique o console.`,!0);endOperation(!1)}else{console.log(`Global filtering for "${t}" was cancelled.`);if(!isLoading){cleanupUIState();if(speedDialContainerEl)speedDialContainerEl.style.display='flex';if(controlsContainerEl)controlsContainerEl.style.display='none';if(document.body)document.body.classList.add('initial-load');activateLuckyFeature();setSpeedDialStatus(`Filtragem global por "${t}" cancelada.`,!1);endOperation(!1)}}if(loadingIndicatorEl)loadingIndicatorEl.style.display='none';if(document.body&&!document.body.classList.contains('cover-active')){document.body.classList.remove('cover-active')}}}
    */

    async function displayGlobalMediaByPrefix(targetPrefix) {
        if (!targetPrefix || isLoading) return;
        // Condition for showing: either legacy `allSelectedFiles` is populated (and not empty), or new API `rootDirectoryHandle` is set.
        if (!rootDirectoryHandle && (!allSelectedFiles || allSelectedFiles.length === 0)) {
            setSpeedDialStatus("Selecione a pasta 'Nucleo' primeiro para pesquisa global.", true);
            return;
        }

        if (searchInputEl && searchInputEl.value) searchInputEl.value = '';
        if (searchSuggestionsEl) {
            searchSuggestionsEl.innerHTML = '';
            searchSuggestionsEl.style.display = 'none';
        }

        const operationSignal = beginOperation();
        let coverBlobUrl = null;
        let coverItemName = null;
        const foundCovers = [];
        const foundRegulars = [];

        // It's important that this function uses local arrays (foundCovers, foundRegulars)
        // and then passes a selection to displayMedia. It should not directly modify global `mediaFiles`
        // as that array is typically for the currently loaded "Caminho".

        try {
            updateMainHeader('Random Media');
            resetLuckyFeature();
            if (speedDialContainerEl) speedDialContainerEl.style.display = 'none';
            clearTimeout(window.coverDisplayTimeoutId || 0);
            if (coverOverlayBlur) { coverOverlayBlur.classList.remove('visible'); coverOverlayBlur.style.backgroundImage = 'none'; }
            if (coverOverlay) { coverOverlay.classList.remove('visible'); coverOverlay.style.backgroundImage = 'none'; }
            if (document.body) document.body.classList.remove('cover-active');
            if (loadingIndicatorEl) {
                loadingIndicatorEl.textContent = `Pesquisando por "${targetPrefix}" em todos os Caminhos...`;
                loadingIndicatorEl.style.display = 'block';
            }
            if (operationSignal.aborted) throw new DOMException('Cancelled early (global search)', 'AbortError');

            const entryCounter = { count: 0 }; // Shared counter for scan progress

            if (rootDirectoryHandle) { // New API Path
                const fileProcessorFn = (fileHandle, relativePath, isCover, isOriginal, entryActualPrefix) => {
                    // The scanDirectoryRecursive with a targetPrefix will only yield matching prefixes.
                    const item = {
                        name: fileHandle.name,
                        fileHandle: fileHandle,
                        fileRef: null,
                        relativePath: relativePath,
                        isCoverFile: isCover,
                        isOriginal: isOriginal,
                        prefix: entryActualPrefix,
                        blobUrl: null, type: null, loadSuccess: null, abortController: null
                    };
                    if (isCover) foundCovers.push(item);
                    else foundRegulars.push(item);
                };

                for (const caminhoName of CAMINHO_FOLDER_NAMES) {
                    if (operationSignal.aborted) break;
                    try {
                        const caminhoDirHandle = await rootDirectoryHandle.getDirectoryHandle(caminhoName, { create: false });
                        await consumeAsyncGenerator(scanDirectoryRecursive({
                            directoryHandle: caminhoDirHandle,
                            basePathParts: [caminhoName],
                            targetPrefix: targetPrefix,
                            isCoverScan: false,
                            recursive: true,
                            signal: operationSignal,
                            fileProcessorFn,
                            entryCounter
                        }));
                    } catch (e) {
                        if (e.name !== 'NotFoundError' && e.name !== 'AbortError') console.warn(`Error scanning ${caminhoName} for prefix ${targetPrefix}:`, e);
                    }
                }
                if (operationSignal.aborted) throw new DOMException('Scan cancelled during Caminho iteration (global search)', 'AbortError');

                try {
                    const capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
                    await consumeAsyncGenerator(scanDirectoryRecursive({
                        directoryHandle: capasDirHandle,
                        basePathParts: [CAPAS_FOLDER_NAME],
                        targetPrefix: targetPrefix,
                        isCoverScan: true,
                        recursive: false,
                        signal: operationSignal,
                        fileProcessorFn,
                        entryCounter
                    }));
                } catch (e) {
                    if (e.name !== 'NotFoundError' && e.name !== 'AbortError') console.warn(`Error scanning .capas for prefix ${targetPrefix}:`, e);
                }
                if (operationSignal.aborted) throw new DOMException('Scan cancelled during .capas iteration (global search)', 'AbortError');

            } else if (allSelectedFiles && allSelectedFiles.length > 0) { // Legacy Path
                const lowerCaseTargetPrefix = targetPrefix.toLowerCase();
                const capasPathPrefixString = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}/` : `${CAPAS_FOLDER_NAME}/`;

                for (const file of allSelectedFiles) {
                    if (operationSignal.aborted) throw new DOMException('Scan Cancelled during file iteration (global search legacy)', 'AbortError');
                    entryCounter.count++; // Simulate entry counting for legacy
                    const relativePath = file.webkitRelativePath?.replace(/^\.\//, '');
                    if (!relativePath || !isMediaFile(file.name)) continue;

                    const pathParts = relativePath.split('/');
                    if (pathParts.length < (rootDirName ? 2 : 1)) continue;

                    const fileName = pathParts[pathParts.length - 1];
                    const itemPrefix = getFirstTwoWords(fileName);

                    if (itemPrefix.toLowerCase() !== lowerCaseTargetPrefix) continue;

                    const dirPathFromFile = pathParts.slice(0, -1).join('/') + '/';
                    let isCover = false, isRegularPath = false, isOriginal = false;

                    if (dirPathFromFile === capasPathPrefixString || relativePath.startsWith(capasPathPrefixString)) {
                        isCover = true;
                    } else {
                        for (const cn of CAMINHO_FOLDER_NAMES) {
                            const currentCaminhoPrefix = rootDirName ? `${rootDirName}/${cn}/` : `${cn}/`;
                            if (dirPathFromFile.startsWith(currentCaminhoPrefix)) {
                                isRegularPath = true;
                                const relevantPathParts = rootDirName ? pathParts.slice(1) : pathParts;
                                isOriginal = relevantPathParts.slice(1, -1).some(part => part.toLowerCase() === ORIGINAIS_FOLDER_NAME.toLowerCase());
                                break;
                            }
                        }
                    }

                    if (isCover || isRegularPath) {
                        const item = {
                            name: fileName, fileRef: file, fileHandle: null, relativePath: relativePath,
                            isCoverFile: isCover, isOriginal: isOriginal, prefix: itemPrefix,
                            blobUrl: null, type: null, loadSuccess: null, abortController: null
                        };
                        if (isCover) foundCovers.push(item);
                        else foundRegulars.push(item);
                    }
                }
                 if (loadingIndicatorEl) loadingIndicatorEl.textContent = `Analisando ${entryCounter.count} itens...`;
            }


            if (foundRegulars.length === 0 && foundCovers.length === 0) {
                console.warn(`Prefix "${targetPrefix}" not found anywhere.`);
                if (mediaContainerEl) mediaContainerEl.style.display = 'none';
                if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
                if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                document.body.classList.add('initial-load');
                // activateLuckyFeature(); // Reconsider if this should run or be adapted for global search context
                setSpeedDialStatus(`Prefixo "${targetPrefix}" não encontrado em nenhum Caminho. Tente outro.`, false);
                endOperation(true);
                return;
            }

            let mediaToDisplay = foundRegulars;
            if (mediaToDisplay.length > MAX_FILTERED_ITEMS) {
                mediaToDisplay = getRandomMedia(mediaToDisplay, MAX_FILTERED_ITEMS);
            }

            if (mediaToDisplay.length === 0 && foundCovers.length > 0) {
                 if (mediaContainerEl) {
                    mediaContainerEl.innerHTML = `<p style="text-align: center; width: 100%; padding: 20px 0;">Apenas capas encontradas para "${targetPrefix}". Nenhum item regular para exibir.</p>`;
                    mediaContainerEl.style.display = 'block';
                 }
                 if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
                 document.body.classList.remove('initial-load');
                 if (controlsContainerEl) controlsContainerEl.style.display = 'flex';

                 const coverToShow = foundCovers.filter(c => c.loadSuccess !== false)[0] || foundCovers[0];
                 if (coverToShow) {
                    coverBlobUrl = await loadCoverImageBlobUrl(coverToShow, operationSignal);
                    coverItemName = coverToShow.name;
                 }
            } else if (mediaToDisplay.length === 0) {
                console.warn(`No regular media found globally for prefix "${targetPrefix}".`);
                // This case means no regular items and no covers either (already handled by the first check)
                // So this specific else-if might be redundant if the first check is comprehensive.
                // However, keeping it for safety in case logic evolves.
                if (mediaContainerEl) mediaContainerEl.style.display = 'none';
                if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
                if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                document.body.classList.add('initial-load');
                setSpeedDialStatus(`Nenhum item regular encontrado para "${targetPrefix}" em todos os Caminhos. Selecione outro.`, false);
                endOperation(true);
                return;
            }

            if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
            if (mediaContainerEl && mediaToDisplay.length > 0) mediaContainerEl.style.display = 'block'; // Only show if there's media
            else if (mediaContainerEl) mediaContainerEl.style.display = 'none';

            if (controlsContainerEl) controlsContainerEl.style.display = 'flex';
            document.body.classList.remove('initial-load');

            if (foundCovers.length > 0 && !coverBlobUrl) {
                const suitableCovers = foundCovers.filter(i => i.loadSuccess !== false);
                if (suitableCovers.length > 0) {
                    const randomCover = suitableCovers[Math.floor(Math.random() * suitableCovers.length)];
                    coverBlobUrl = await loadCoverImageBlobUrl(randomCover, operationSignal);
                    coverItemName = randomCover.name;
                }
            }

            if (coverItemName) {
                const username = getInstagramUsername(coverItemName);
                if (username) updateMainHeader('@' + username);
            }

            if (operationSignal.aborted) throw new DOMException('Cancelled during global cover load', 'AbortError');

            if (coverBlobUrl) {
                if (coverOverlayBlur) { coverOverlayBlur.style.backgroundImage = `url('${coverBlobUrl}')`; requestAnimationFrame(() => { if (!operationSignal.aborted) coverOverlayBlur.classList.add('visible'); }); }
                if (coverOverlay) { coverOverlay.style.backgroundImage = `url('${coverBlobUrl}')`; requestAnimationFrame(() => { if (!operationSignal.aborted) coverOverlay.classList.add('visible'); }); }
                if (document.body && !operationSignal.aborted) document.body.classList.add('cover-active');

                window.coverDisplayTimeoutId = setTimeout(async () => {
                    if (operationSignal.aborted) return;
                    try {
                        await displayMedia(mediaToDisplay, operationSignal, false); // mediaToDisplay is already filtered regulars
                        endOperation(true);
                    } catch (displayError) {
                        if (displayError.name !== 'AbortError') {
                            console.error("Error during post-cover global media display:", displayError);
                            setSpeedDialStatus(`Erro ao exibir mídia global para "${targetPrefix}" após a capa.`, true);
                        }
                        endOperation(false);
                    }
                }, mediaToDisplay.length > 0 ? COVER_DISPLAY_DELAY : 0);
            } else {
                await displayMedia(mediaToDisplay, operationSignal, false); // mediaToDisplay is already filtered regulars
                endOperation(true);
            }
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error(`Error global filtering for prefix "${targetPrefix}":`, e);
                if (mediaContainerEl) mediaContainerEl.style.display = 'none';
                if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
                if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                document.body.classList.add('initial-load');
                setSpeedDialStatus(`Erro ao filtrar globalmente por "${targetPrefix}". Verifique o console.`, true);
                endOperation(false);
            } else {
                console.log(`Global filtering for "${targetPrefix}" was cancelled.`);
                if (!isLoading) {
                    cleanupUIState();
                    if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                    if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                    if(document.body) document.body.classList.add('initial-load');
                    setSpeedDialStatus(`Filtragem global por "${targetPrefix}" cancelada.`, false);
                    endOperation(false);
                }
            }
            if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
            if (document.body && !document.body.classList.contains('cover-active')) {
                 document.body.classList.remove('cover-active');
            }
        }
    }

    function updateFullscreenTransform(){if(!fullscreenImgEl)return;fullscreenImgEl.style.transform=`translate(${imgOffsetX}px, ${imgOffsetY}px) rotate(${rotationAngle}deg) scale(${zoomScale})`}
    function showFullscreenMedia(s,t){if(!fullscreenMediaEl||!fullscreenImgEl||!fullscreenVideoEl||!rotateButtonEl)return;rotationAngle=0;zoomScale=1;imgOffsetX=0;imgOffsetY=0;isDragging=!1;fullscreenVideoEl.pause();fullscreenVideoEl.removeAttribute('src');if(fullscreenVideoEl.readyState>0){try{fullscreenVideoEl.load()}catch(e){}}fullscreenImgEl.removeAttribute('src');fullscreenImgEl.style.display='none';fullscreenVideoEl.style.display='none';fullscreenImgEl.removeEventListener('wheel',handleWheelZoom);fullscreenImgEl.removeEventListener('mousedown',handleMouseDownDrag);document.removeEventListener('mousemove',handleMouseMoveDrag);document.removeEventListener('mouseup',handleMouseUpDrag);fullscreenImgEl.onload=null;fullscreenImgEl.onerror=null;if(t?.startsWith('image')){fullscreenImgEl.style.display='block';rotateButtonEl.style.display='block';updateFullscreenTransform();fullscreenImgEl.onload=()=>{const c=fullscreenMediaEl.clientWidth*.9,h=fullscreenMediaEl.clientHeight*.9,i=fullscreenImgEl.naturalWidth/fullscreenImgEl.naturalHeight,r=c/h;let l;if(i>r){l=c/fullscreenImgEl.naturalWidth}else{l=h/fullscreenImgEl.naturalHeight}zoomScale=Math.min(l,1);fullscreenImgEl.style.width=`${fullscreenImgEl.naturalWidth*zoomScale}px`;fullscreenImgEl.style.height=`${fullscreenImgEl.naturalHeight*zoomScale}px`;imgOffsetX=0;imgOffsetY=0;updateFullscreenTransform();fullscreenImgEl.style.width='auto';fullscreenImgEl.style.height='auto';fullscreenImgEl.onload=null};fullscreenImgEl.onerror=()=>{console.error("Falha ao carregar imagem em tela cheia:",s);closeFullscreenMedia();fullscreenImgEl.onload=null;fullscreenImgEl.onerror=null};fullscreenImgEl.src=s;fullscreenImgEl.addEventListener('wheel',handleWheelZoom,{passive:!1});fullscreenImgEl.addEventListener('mousedown',handleMouseDownDrag)}else if(t?.startsWith('video')){fullscreenVideoEl.src=s;fullscreenVideoEl.style.display='block';rotateButtonEl.style.display='none';fullscreenVideoEl.play().catch(e=>console.warn("Autoplay bloqueado:",e))}else{console.warn("Tipo de mídia não suportado para fullscreen:",t);return}fullscreenMediaEl.style.display='flex'}
    function handleWheelZoom(e){e.preventDefault();e.stopPropagation();if(!fullscreenImgEl||fullscreenImgEl.style.display==='none')return;const r=fullscreenImgEl.getBoundingClientRect();if(r.width===0||r.height===0)return;const d=e.deltaY,s=d<0?ZOOM_SENSITIVITY:1/ZOOM_SENSITIVITY,o=zoomScale;let n=o*s;n=Math.max(MIN_ZOOM,Math.min(n,MAX_ZOOM));if(n===o)return;const m=e.clientX,y=e.clientY,cX=r.left+r.width/2,cY=r.top+r.height/2,pX_B=m-cX,pY_B=y-cY,pX_A=pX_B*(n/o),pY_A=pY_B*(n/o),dX=pX_B-pX_A,dY=pY_B-pY_A;imgOffsetX+=dX;imgOffsetY+=dY;zoomScale=n;requestAnimationFrame(updateFullscreenTransform)}
    function handleMouseDownDrag(e){e.preventDefault();e.stopPropagation();if(e.button!==0||!fullscreenImgEl||fullscreenImgEl.style.display==='none')return;isDragging=!0;dragStartX=e.clientX;dragStartY=e.clientY;dragStartOffsetX=imgOffsetX;dragStartOffsetY=imgOffsetY;fullscreenImgEl.classList.add('grabbing');fullscreenImgEl.style.transition='none';document.addEventListener('mousemove',handleMouseMoveDrag);document.addEventListener('mouseup',handleMouseUpDrag)}
    function handleMouseMoveDrag(e){if(!isDragging)return;e.preventDefault();e.stopPropagation();const cX=e.clientX,cY=e.clientY,dX=cX-dragStartX,dY=cY-dragStartY;imgOffsetX=dragStartOffsetX+dX;imgOffsetY=dragStartOffsetY+dY;requestAnimationFrame(updateFullscreenTransform)}
    function handleMouseUpDrag(e){if(!isDragging||e.button!==0)return;e.preventDefault();e.stopPropagation();isDragging=!1;fullscreenImgEl.classList.remove('grabbing');fullscreenImgEl.style.transition='';document.removeEventListener('mousemove',handleMouseMoveDrag);document.removeEventListener('mouseup',handleMouseUpDrag)}
    function rotateImage(e){e.stopPropagation();if(!fullscreenImgEl||isDragging)return;const rB=fullscreenImgEl.getBoundingClientRect(),cXB=rB.left+rB.width/2,cYB=rB.top+rB.height/2;rotationAngle=(rotationAngle+90)%360;updateFullscreenTransform();requestAnimationFrame(()=>{const rA=fullscreenImgEl.getBoundingClientRect(),cXA=rA.left+rA.width/2,cYA=rA.top+rA.height/2,dX=cXB-cXA,dY=cYB-cYA;imgOffsetX+=dX;imgOffsetY+=dY;updateFullscreenTransform()})}
    function closeFullscreenMedia(){if(!fullscreenMediaEl||!fullscreenVideoEl||!fullscreenImgEl)return;fullscreenMediaEl.style.display='none';fullscreenVideoEl.pause();fullscreenVideoEl.removeAttribute('src');if(fullscreenVideoEl.readyState>0){try{fullscreenVideoEl.load()}catch(e){console.warn("Error trying to unload video:",e)}}fullscreenImgEl.removeAttribute('src');fullscreenImgEl.onload=null;fullscreenImgEl.onerror=null;fullscreenImgEl.style.transform='none';fullscreenImgEl.style.width='auto';fullscreenImgEl.style.height='auto';fullscreenImgEl.removeEventListener('wheel',handleWheelZoom);fullscreenImgEl.removeEventListener('mousedown',handleMouseDownDrag);document.removeEventListener('mousemove',handleMouseMoveDrag);document.removeEventListener('mouseup',handleMouseUpDrag);isDragging=!1;fullscreenImgEl.classList.remove('grabbing');fullscreenImgEl.style.display='none'}
    function getIconBaseName(o){const m=o.match(/\d+$/);return m?`icon${m[0]}`:`icon_${o.replace(/[^a-z0-9]/gi,'_')}`}
    function findFileByPath(f,r){if(!f)return null;const n=r.replace(/^\.\//,'');for(const i of f){const p=i.webkitRelativePath?.replace(/^\.\//,'');if(p===n){return i}}return null}
    function revokeGeneratedBlobUrls(){let c=0;for(const u of iconBlobUrls.values()){if(u){try{URL.revokeObjectURL(u);c++}catch(e){}}}iconBlobUrls.clear();if(faviconBlobUrl){try{URL.revokeObjectURL(faviconBlobUrl)}catch(e){}}faviconBlobUrl=null;if(faviconElement)faviconElement.href='#'}
    function resetSpeedDialIcons(){revokeGeneratedBlobUrls();if(speedDialOptionsEl){speedDialOptionsEl.querySelectorAll('.speed-dial-item').forEach(i=>{i.classList.remove('icon-error');const m=i.querySelector('img.speed-dial-icon');if(m){m.src='';m.classList.remove('loaded')}})}}
    function resetFavicon(){if(faviconBlobUrl){try{URL.revokeObjectURL(faviconBlobUrl)}catch(e){}}faviconBlobUrl=null;if(faviconElement)faviconElement.href='#'}

    async function loadSpecificIcons(sourceOrSignal) { // Can be allSelectedFiles (legacy) or AbortSignal (new API)
        if (!speedDialOptionsEl) return;
        // Do not call resetSpeedDialIcons() here as it's called by handleDirectoryPickerSelection / handleFolderSelectionLegacy prior to this.
        // resetSpeedDialIcons();

        let statusMessageSuffix = "ícones atualizados.";

        if (rootDirectoryHandle) { // New API Path
            const signal = sourceOrSignal instanceof AbortSignal ? sourceOrSignal : null;
            let capasDirHandle;
            try {
                // Use CAPAS_FOLDER_NAME directly as rootDirectoryHandle is the root.
                capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
            } catch (e) {
                if (e.name === 'NotFoundError') console.warn(`loadSpecificIcons: Diretório de capas "${CAPAS_FOLDER_NAME}" não encontrado na raiz.`);
                else console.error(`loadSpecificIcons: Erro ao acessar diretório de capas:`, e);
                // Optionally set a status message or handle this error more visibly
                // For now, icons will just not load.
                return;
            }
            if (signal?.aborted) return;

            const iconLoadPromises = speedDialConfig.map(async config => {
                const itemElement = speedDialOptionsEl.querySelector(`.speed-dial-item[data-caminho="${config.originalName}"]`);
                if (!itemElement) return;
                const iconImgElement = itemElement.querySelector('img.speed-dial-icon');
                if (!iconImgElement) return;

                const baseName = getIconBaseName(config.originalName);
                const possibleNames = [`${baseName}.avif`, `${baseName}.jpg`, `${baseName}.png`, `${baseName}.jpeg`];
                let foundFile = null;
                let foundFileHandle = null;

                for (const name of possibleNames) {
                    if (signal?.aborted) return;
                    try {
                        foundFileHandle = await capasDirHandle.getFileHandle(name, { create: false });
                        if (foundFileHandle) {
                            foundFile = await foundFileHandle.getFile(); // Get the actual File object
                            break;
                        }
                    } catch (e) { /* File not found, try next */ }
                }

                if (signal?.aborted) return;

                if (foundFile) {
                    try {
                        const oldBlobUrl = iconBlobUrls.get(config.originalName);
                        if (oldBlobUrl) URL.revokeObjectURL(oldBlobUrl);

                        const newBlobUrl = URL.createObjectURL(foundFile);
                        iconBlobUrls.set(config.originalName, newBlobUrl);
                        iconImgElement.src = newBlobUrl;
                        iconImgElement.alt = `Ícone para ${config.displayName}`;
                        itemElement.classList.remove('icon-error');
                        iconImgElement.onload = () => iconImgElement.classList.add('loaded');
                        iconImgElement.onerror = () => {
                            itemElement.classList.add('icon-error');
                            URL.revokeObjectURL(newBlobUrl);
                            iconBlobUrls.delete(config.originalName);
                            console.error(`Falha ao carregar imagem do ícone: ${foundFile.name}`);
                        };
                    } catch (blobError) {
                        itemElement.classList.add('icon-error');
                        console.error("Erro ao criar blob para ícone:", config.originalName, blobError);
                    }
                } else {
                    itemElement.classList.add('icon-error');
                }
            });
            await Promise.allSettled(iconLoadPromises);
            statusMessageSuffix = "Ícones verificados (API).";

        } else if (sourceOrSignal && Array.isArray(sourceOrSignal)) { // Legacy Path using allSelectedFiles array
            const allSelectedFiles = sourceOrSignal;
            const legacyLoadPromises = speedDialConfig.map(async c => {
                const i = speedDialOptionsEl.querySelector(`.speed-dial-item[data-caminho="${c.originalName}"]`);
                if (!i) return;
                const b = getIconBaseName(c.originalName);
                // Path construction for legacy needs to include rootDirName if present
                const capasDir = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}` : CAPAS_FOLDER_NAME;
                const pA = `${capasDir}/${b}.avif`, pJ = `${capasDir}/${b}.jpg`, pN = `${capasDir}/${b}.png`, pJE = `${capasDir}/${b}.jpeg`;

                let fileObject = findFileByPath(allSelectedFiles, pA) ||
                                 findFileByPath(allSelectedFiles, pJ) ||
                                 findFileByPath(allSelectedFiles, pN) ||
                                 findFileByPath(allSelectedFiles, pJE);

                const m = i.querySelector('img.speed-dial-icon');
                if (fileObject && m) {
                    try {
                        const o = iconBlobUrls.get(c.originalName);
                        if (o) { try { URL.revokeObjectURL(o); } catch (e) { /* ignore */ } }
                        const u = URL.createObjectURL(fileObject);
                        iconBlobUrls.set(c.originalName, u);
                        m.src = u;
                        m.alt = `Ícone para ${c.displayName}`;
                        m.onload = () => m.classList.add('loaded');
                        m.onerror = () => { i.classList.add('icon-error'); URL.revokeObjectURL(u); iconBlobUrls.delete(c.originalName); console.error(`Failed to load icon image: ${fileObject?.name}`); };
                        i.classList.remove('icon-error');
                    } catch (r) { i.classList.add('icon-error'); if (m) m.src = ''; console.error("Error creating blob for icon (legacy):", c.originalName, r); }
                } else { i.classList.add('icon-error'); if (m) m.src = ''; }
            });
            await Promise.allSettled(legacyLoadPromises);
            statusMessageSuffix = `Ícones verificados (legado: ${allSelectedFiles.length} arquivos).`;
        }
        // The status message is usually set by the calling function (handleDirectoryPickerSelection or handleFolderSelectionLegacy)
        // console.log("loadSpecificIcons complete:", statusMessageSuffix);
    }

    async function loadSpecificFavicon(sourceOrSignal) { // Can be allSelectedFiles (legacy) or AbortSignal (new API)
        if (!faviconElement) return;
        resetFavicon(); // Clear existing favicon
        let foundFaviconFile = null;

        if (rootDirectoryHandle) { // New API Path
            const signal = sourceOrSignal instanceof AbortSignal ? sourceOrSignal : null;
            let capasDirHandle;
            try {
                // Use CAPAS_FOLDER_NAME directly as rootDirectoryHandle is the root.
                capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
            } catch (e) {
                if (e.name === 'NotFoundError') console.warn(`loadSpecificFavicon: Diretório de capas "${CAPAS_FOLDER_NAME}" não encontrado.`);
                else console.error(`loadSpecificFavicon: Erro ao acessar diretório de capas:`, e);
                return;
            }
            if (signal?.aborted) return;

            const possibleNames = ['fav.avif', 'fav.jpg', 'fav.png', 'fav.jpeg'];
            for (const name of possibleNames) {
                if (signal?.aborted) return;
                try {
                    const fileHandle = await capasDirHandle.getFileHandle(name, { create: false });
                    if (fileHandle) {
                        foundFaviconFile = await fileHandle.getFile(); // Get the actual File object
                        break;
                    }
                } catch (e) { /* File not found, try next */ }
            }
            if (signal?.aborted && foundFaviconFile) { /* Blob not created yet, safe to return */ return; }

        } else if (sourceOrSignal && Array.isArray(sourceOrSignal)) { // Legacy Path
            const allSelectedFiles = sourceOrSignal;
            const capasDir = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}` : CAPAS_FOLDER_NAME;
            const favAVIF = `${capasDir}/fav.avif`;
            const favJPG = `${capasDir}/fav.jpg`;
            const favPNG = `${capasDir}/fav.png`;
            const favJPEG = `${capasDir}/fav.jpeg`;
            foundFaviconFile = findFileByPath(allSelectedFiles, favAVIF) ||
                               findFileByPath(allSelectedFiles, favJPG) ||
                               findFileByPath(allSelectedFiles, favPNG) ||
                               findFileByPath(allSelectedFiles, favJPEG);
        }

        if (foundFaviconFile) {
            try {
                faviconBlobUrl = URL.createObjectURL(foundFaviconFile);
                faviconElement.href = faviconBlobUrl;
            } catch (r) {
                console.error("Error creating blob URL for favicon:", r);
                resetFavicon(); // Ensure it's reset if blob creation fails
            }
        }
    }
    
    async function getLuckyCoverCandidates(signal) { // Made async, accepts signal
        if (rootDirectoryHandle) { // New API Path
            let capasDirHandle;
            try {
                capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
            } catch (e) {
                console.warn(`Lucky: Diretório de capas "${CAPAS_FOLDER_NAME}" não encontrado.`);
                return [];
            }
            if (signal?.aborted) return [];

            const candidates = [];
            try {
                for await (const entry of capasDirHandle.values()) {
                    if (signal?.aborted) break;
                    if (entry.kind === 'file' && isImageFile(entry.name) && !ICON_NAME_REGEX.test(entry.name)) {
                        candidates.push({
                            fileHandle: entry, // Store the handle
                            name: entry.name,
                            prefix: getFirstTwoWords(entry.name),
                            relativePath: (rootDirName ? `${rootDirName}/` : '') + `${CAPAS_FOLDER_NAME}/${entry.name}`
                        });
                    }
                }
            } catch (e) {
                 if (e.name !== 'AbortError') console.error("Error iterating .capas for lucky candidates:", e);
            }
            return candidates;

        } else if (allSelectedFiles && allSelectedFiles.length > 0) { // Legacy Path
            const capasFolderPath = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}/` : `${CAPAS_FOLDER_NAME}/`;
            const candidates = [];
            for (const file of allSelectedFiles) {
                 if (signal?.aborted) break;
                const relativePath = file.webkitRelativePath?.replace(/^\.\//, '');
                const fileName = file.name;
                if (relativePath &&
                    relativePath.startsWith(capasFolderPath) &&
                    isImageFile(fileName) &&
                    !ICON_NAME_REGEX.test(fileName)
                ) {
                    candidates.push({
                        fileRef: file, // Store the file object
                        prefix: getFirstTwoWords(fileName),
                        name: fileName,
                        relativePath: relativePath
                    });
                }
            }
            return candidates;
        }
        return []; // Default if no source is available
    }

    function resetLuckyFeature() {
        if (luckyImageBlobUrl) {
            try { URL.revokeObjectURL(luckyImageBlobUrl); } catch (e) { console.warn("Error revoking lucky blob", e); }
            luckyImageBlobUrl = null;
        }
        currentLuckyFileItem = null;
        if (luckyImageEl) luckyImageEl.src = "#";
        if (luckyImageTextEl) {
            luckyImageTextEl.textContent = '';
            luckyImageTextEl.style.display = 'none';
        }
        if (luckyImageWrapperEl) {
            luckyImageWrapperEl.style.display = 'none';
        }
        if (luckyFeatureContainerEl) {
             luckyFeatureContainerEl.style.display = 'none';
        }
        if (speedDialContainerEl) {
            speedDialContainerEl.style.removeProperty('--speed-dial-background-image-url');
        }
        luckyFeatureState = 'initial';
    }

    async function activateLuckyFeature() {
        const folderSelected = rootDirectoryHandle || (allSelectedFiles && allSelectedFiles.length > 0);
        if (isLoading || !folderSelected || !speedDialContainerEl || speedDialContainerEl.style.display === 'none') {
            resetLuckyFeature();
            return;
        }
        resetLuckyFeature(); 
        const s = currentOperationController ? currentOperationController.signal : null;

        try {
            const candidates = await getLuckyCoverCandidates(s); // Now async
            if (s?.aborted) { resetLuckyFeature(); return; }

            if (candidates.length === 0) {
                if(luckyFeatureContainerEl) luckyFeatureContainerEl.style.display = 'none';
                return;
            }

            const luckyFile = candidates[Math.floor(Math.random() * candidates.length)];

            currentLuckyFileItem = {
                name: luckyFile.name,
                fileRef: luckyFile.fileRef || null,     // From legacy or to be filled by getFile()
                fileHandle: luckyFile.fileHandle || null, // From new API
                relativePath: luckyFile.relativePath,
                isCoverFile: true, 
                isOriginal: false, 
                prefix: luckyFile.prefix,
                blobUrl: null, type: null, loadSuccess: null, abortController: null
            };
            
            const blobLoaded = await loadBlobForItem(currentLuckyFileItem, s);
            if (s?.aborted) throw new DOMException("Lucky feature cancelled during blob load", "AbortError");

            if (blobLoaded && currentLuckyFileItem.blobUrl) {
                luckyImageBlobUrl = currentLuckyFileItem.blobUrl;
                if(luckyImageEl) {
                    luckyImageEl.src = luckyImageBlobUrl;
                    luckyImageEl.alt = `Capa da sorte: ${currentLuckyFileItem.prefix}`;
                }
                if(luckyImageWrapperEl) {
                    luckyImageWrapperEl.style.display = 'block';
                }
                if(luckyImageTextEl) luckyImageTextEl.style.display = 'none';
                if(luckyFeatureContainerEl) luckyFeatureContainerEl.style.display = 'block';
                
                if (speedDialContainerEl && luckyImageBlobUrl) {
                    speedDialContainerEl.style.setProperty('--speed-dial-background-image-url', `url('${luckyImageBlobUrl}')`);
                }
                luckyFeatureState = 'image_ready';
            } else {
                console.warn("Failed to load blob for lucky image, or operation aborted.");
                resetLuckyFeature(); 
            }
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error("Error in activateLuckyFeature:", e);
                setSpeedDialStatus(`Erro ao mostrar imagem da sorte: ${e.message || 'Erro desconhecido'}`, true);
            }
            resetLuckyFeature();
        }
    }

    async function handleLuckyImageClick() {
        if (isLoading || !currentLuckyFileItem || !luckyImageWrapperEl) return;

        if (luckyFeatureState === 'image_ready') {
            if (luckyImageTextEl) {
                luckyImageTextEl.textContent = `Explore mais de "${currentLuckyFileItem.prefix}"`;
                luckyImageTextEl.style.display = 'block';
            }
            luckyFeatureState = 'explore_ready';
        } else if (luckyFeatureState === 'explore_ready' && currentLuckyFileItem.prefix) {
            if(speedDialContainerEl) speedDialContainerEl.style.display = 'none';
            document.body.classList.remove('initial-load');
            hideCaminhoSidebar(); 
            await displayGlobalMediaByPrefix(currentLuckyFileItem.prefix);
        }
    }

    function showCaminhoSidebar(caminhoName, items) {
        if (!caminhoSidebarEl || !caminhoSidebarListEl || !caminhoSidebarTitleEl) return;
        
        const speedDialEntry = speedDialConfig.find(cfg => cfg.originalName === caminhoName);
        const displayName = speedDialEntry ? speedDialEntry.displayName : caminhoName;

        caminhoSidebarTitleEl.textContent = `Navegar em "${displayName}"`;
        caminhoSidebarListEl.innerHTML = ''; 

        if (items.length === 0) {
            const li = document.createElement('li');
            li.textContent = 'Nenhum nome único encontrado.';
            li.style.cursor = 'default';
            caminhoSidebarListEl.appendChild(li);
        } else {
            items.forEach(itemPrefix => {
                const li = document.createElement('li');
                li.textContent = itemPrefix;
                li.title = `Pesquisar por "${itemPrefix}"`;
                li.addEventListener('click', () => {
                    if (!isLoading) {
                        displayGlobalMediaByPrefix(itemPrefix);
                    }
                });
                caminhoSidebarListEl.appendChild(li);
            });
        }
        caminhoSidebarEl.classList.add('visible');
        document.body.classList.add('sidebar-active');
    }

    function hideCaminhoSidebar() {
        if (caminhoSidebarEl) {
            caminhoSidebarEl.classList.remove('visible');
        }
        document.body.classList.remove('sidebar-active');
    }

    // Helper to fully consume an async generator, ensuring all its operations complete.
    async function consumeAsyncGenerator(asyncGenerator) {
        for await (const _ of asyncGenerator) { /* just consume to drive execution */ }
    }

    async function* scanDirectoryRecursive({
        directoryHandle,
        basePathParts = [],
        targetPrefix = null,
        isCoverScan = false,
        recursive = true,
        signal,
        fileProcessorFn,
        entryCounter = { count: 0 }
    }) {
        if (signal?.aborted) throw new DOMException('Operation cancelled during scan', 'AbortError');

        let currentDirectoryDisplayName = basePathParts.length > 0 ? basePathParts[basePathParts.length-1] : rootDirName;

        try {
            for await (const entry of directoryHandle.values()) {
                if (signal?.aborted) throw new DOMException('Operation cancelled during directory iteration', 'AbortError');

                entryCounter.count++;
                if (entryCounter.count % 100 === 0 && loadingIndicatorEl && isLoading) {
                    // Update loading indicator text more dynamically
                    let statusText = `Verificando item ${entryCounter.count}`;
                    if (targetPrefix) statusText += ` por "${targetPrefix}"`;
                    statusText += ` em "${currentDirectoryDisplayName}"...`;
                    loadingIndicatorEl.textContent = statusText;
                    await delay(1, signal);
                }

                if (entry.kind === 'file') {
                    if (isMediaFile(entry.name)) {
                        const entryActualPrefix = getFirstTwoWords(entry.name); // Renamed to avoid conflict
                        if (targetPrefix && entryActualPrefix.toLowerCase() !== targetPrefix.toLowerCase()) {
                            continue;
                        }
                        const fullPath = [rootDirName, ...basePathParts, entry.name].filter(Boolean).join('/');
                        const isOriginal = !isCoverScan && basePathParts.some(part => part.toLowerCase() === ORIGINAIS_FOLDER_NAME.toLowerCase());

                        fileProcessorFn(entry, fullPath, isCoverScan, isOriginal, entryActualPrefix);
                    }
                } else if (entry.kind === 'directory' && recursive && !isCoverScan) {
                    const shouldRecurse = entry.name.toLowerCase() === ORIGINAIS_FOLDER_NAME.toLowerCase() ||
                                          (!targetPrefix && basePathParts.length < 2); // Smart recursion for general scans

                    if (shouldRecurse) {
                        try {
                            const subDirHandle = await directoryHandle.getDirectoryHandle(entry.name, { create: false });
                            // Yield* from the recursive call to continue the iteration properly
                            yield* scanDirectoryRecursive({
                                directoryHandle: subDirHandle,
                                basePathParts: [...basePathParts, entry.name],
                                targetPrefix,
                                isCoverScan,
                                recursive: true,
                                signal,
                                fileProcessorFn,
                                entryCounter
                            });
                        } catch (subDirError) {
                            if (subDirError.name === 'NotFoundError') {
                                // console.warn(`Subdirectory ${entry.name} not found in ${basePathParts.join('/')}`);
                            } else if (subDirError.name !== 'AbortError') {
                                console.error(`Error accessing subdirectory ${entry.name} in ${basePathParts.join('/')}:`, subDirError);
                            }
                        }
                    }
                }
            }
        } catch (dirError) {
            if (dirError.name === 'NotFoundError') {
                // console.warn(`Directory not found: ${basePathParts.join('/')}`, dirError);
            } else if (dirError.name !== 'AbortError') {
                console.error(`Error iterating directory handle ${basePathParts.join('/') || rootDirName}:`, dirError);
                // Do not re-throw NotFoundError from top-level calls like specific Caminho or .capas,
                // as they might legitimately not exist.
                if (basePathParts.length > 0) throw dirError;
            }
        }
    }


    async function processAndDisplayFilesForPath(caminhoName) {
        const operationSignal = beginOperation();
        resetLuckyFeature();
        try {
            updateMainHeader('Random Media');
            if (speedDialContainerEl) speedDialContainerEl.style.display = 'none';
            document.body.classList.remove('initial-load');
            cleanupUIState();
            mediaFiles.forEach(revokeItemResources);
            mediaFiles = []; // Clear global mediaFiles
            mediaIndex.clear();
            initialViewHistory = [];
            sessionViewedPrefixes.clear();

            if (loadingIndicatorEl) {
                loadingIndicatorEl.textContent = `Processando "${caminhoName}"...`;
                loadingIndicatorEl.style.display = 'block';
            }

            const fileProcessorFn = (fileHandle, relativePath, isCoverFile, isOriginal, entryPrefix) => {
                mediaFiles.push({
                    name: fileHandle.name,
                    fileHandle: fileHandle,
                    fileRef: null,
                    relativePath: relativePath,
                    isCoverFile: isCoverFile,
                    isOriginal: isOriginal,
                    prefix: entryPrefix, // Use the passed entryPrefix
                    blobUrl: null, type: null, loadSuccess: null, abortController: null
                });
            };

            const entryCounter = { count: 0 }; // Shared counter

            if (rootDirectoryHandle) { // New API Path
                // 1. Process files from the specific "Caminho X" directory (and its 'originais')
                try {
                    const caminhoDirHandle = await rootDirectoryHandle.getDirectoryHandle(caminhoName, { create: false });
                    await consumeAsyncGenerator(scanDirectoryRecursive({
                        directoryHandle: caminhoDirHandle,
                        basePathParts: [caminhoName],
                        targetPrefix: null, // Process all media files in this Caminho
                        isCoverScan: false,
                        recursive: true, // Allow recursion for 'originais'
                        signal: operationSignal,
                        fileProcessorFn,
                        entryCounter
                    }));
                } catch (e) {
                    if (e.name === 'NotFoundError') {
                        console.warn(`Caminho directory "${caminhoName}" not found in root.`);
                    } else if (e.name !== 'AbortError') {
                         console.error(`Error processing Caminho "${caminhoName}":`, e);
                        // We might still want to try loading covers even if a caminho fails.
                        // throw e;
                    }
                }
                if (operationSignal.aborted) throw new DOMException('Processing cancelled after Caminho files', 'AbortError');

                // 2. Process files from the ".capas" directory
                try {
                    const capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
                    await consumeAsyncGenerator(scanDirectoryRecursive({
                        directoryHandle: capasDirHandle,
                        basePathParts: [CAPAS_FOLDER_NAME],
                        targetPrefix: null, // Process all media files in .capas
                        isCoverScan: true,
                        recursive: false, // No subdirectories expected in .capas
                        signal: operationSignal,
                        fileProcessorFn,
                        entryCounter
                    }));
                } catch (e) {
                    if (e.name === 'NotFoundError') {
                        console.warn(`"${CAPAS_FOLDER_NAME}" directory not found in root. No covers will be loaded.`);
                    } else if (e.name !== 'AbortError') {
                        console.error(`Error processing .capas directory:`, e);
                        // throw e;
                    }
                }
                if (operationSignal.aborted) throw new DOMException('Processing cancelled after .capas files', 'AbortError');

            } else if (allSelectedFiles) { // Legacy Path (using allSelectedFiles)
                const pathPrefix = rootDirName ? `${rootDirName}/${caminhoName}/` : `${caminhoName}/`;
                const coverPathPrefix = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}/` : `${CAPAS_FOLDER_NAME}/`;
                let filesProcessedCount = 0;

                for (const file of allSelectedFiles) {
                    let filesProcessedCountLegacy = 0; // Renamed to avoid conflict
                    for (const file of allSelectedFiles) {
                        if (operationSignal.aborted) throw new DOMException('Scan Cancelled during file iteration (legacy)', 'AbortError');
                        filesProcessedCountLegacy++;
                        if (filesProcessedCountLegacy % 100 === 0 && loadingIndicatorEl && isLoading) {
                            loadingIndicatorEl.textContent = `Processando arquivos para "${caminhoName}"... (${filesProcessedCountLegacy}/${allSelectedFiles.length})`;
                            await delay(1, operationSignal);
                        }

                        const relativePath = file.webkitRelativePath?.replace(/^\.\//, '');
                        if (!relativePath || !isMediaFile(file.name)) continue;

                        const pathParts = relativePath.split('/');
                        if (pathParts.length < (rootDirName ? 2 : 1)) continue;

                        const fileName = pathParts[pathParts.length - 1];
                        const directoryPathFromFile = pathParts.slice(0, -1).join('/') + '/';

                        const pathPrefixLegacy = rootDirName ? `${rootDirName}/${caminhoName}/` : `${caminhoName}/`; // Renamed
                        const coverPathPrefixLegacy = rootDirName ? `${rootDirName}/${CAPAS_FOLDER_NAME}/` : `${CAPAS_FOLDER_NAME}/`; // Renamed

                        const isCover = directoryPathFromFile === coverPathPrefixLegacy || relativePath.startsWith(coverPathPrefixLegacy);
                        let isRegular = directoryPathFromFile.startsWith(pathPrefixLegacy);
                        let isOriginal = false;

                        if (isRegular) {
                            const relevantPathParts = rootDirName ? pathParts.slice(1) : pathParts;
                            isOriginal = relevantPathParts.slice(1, -1).some(part => part.toLowerCase() === ORIGINAIS_FOLDER_NAME.toLowerCase());
                        }

                        if (isCover || isRegular) {
                            mediaFiles.push({
                                name: fileName,
                                fileRef: file,
                                fileHandle: null,
                                relativePath: relativePath,
                                isCoverFile: isCover,
                                isOriginal: isOriginal,
                                prefix: getFirstTwoWords(fileName),
                                blobUrl: null, type: null, loadSuccess: null, abortController: null
                            });
                        }
                    }
                } else {
                     setSpeedDialStatus("Erro: Nenhuma fonte de arquivos (API ou legado) disponível.", true);
                     throw new Error("No file source available for processAndDisplayFilesForPath");
                }

                if (operationSignal.aborted) throw new DOMException('Processing Operation Cancelled after file iteration', 'AbortError');
                if (loadingIndicatorEl) loadingIndicatorEl.textContent = `Analisando ${mediaFiles.length} itens coletados...`;

                if (mediaFiles.length > 0) {
                    if (loadingIndicatorEl) loadingIndicatorEl.textContent = `Indexando ${mediaFiles.length} itens...`;
                buildMediaIndex(operationSignal);
                if (operationSignal.aborted) throw new DOMException('Indexing Cancelled', 'AbortError');

                const regularMediaFiles = mediaFiles.filter(i => !i.isCoverFile);
                if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';

                if (regularMediaFiles.length > 0) {
                    if (controlsContainerEl) controlsContainerEl.style.display = 'flex';
                    await displayMedia(getRandomInitialMedia(regularMediaFiles, MAX_INITIAL_ITEMS), operationSignal, true);

                    const uniquePrefixesInPath = Array.from(new Set(regularMediaFiles.map(file => file.prefix).filter(Boolean))).sort((a, b) => a.localeCompare(b));
                    showCaminhoSidebar(caminhoName, uniquePrefixesInPath);
                } else {
                    if (mediaContainerEl) mediaContainerEl.style.display = 'none';
                    if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                    if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                    document.body.classList.add('initial-load');
                    activateLuckyFeature();
                    setSpeedDialStatus(`"${caminhoName}" não contém arquivos de mídia regulares. Selecione outro.`, false);
                    hideCaminhoSidebar();
                    endOperation(true);
                    return;
                }
            } else {
                if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
                if (mediaContainerEl) mediaContainerEl.style.display = 'none';
                if (controlsContainerEl) controlsContainerEl.style.display = 'none';
                if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
                document.body.classList.add('initial-load');
                activateLuckyFeature();
                setSpeedDialStatus(`Nenhum arquivo de mídia relevante encontrado para "${caminhoName}". Selecione outro.`, false);
                hideCaminhoSidebar();
                endOperation(true);
                return;
            }
            endOperation(true);
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error(`Error processing path "${caminhoName}":`, e);
            }
            cleanupUIState();
            if (mediaContainerEl) mediaContainerEl.style.display = 'none';
            if (controlsContainerEl) controlsContainerEl.style.display = 'none';
            if (speedDialContainerEl) speedDialContainerEl.style.display = 'flex';
            document.body.classList.add('initial-load');
            if (loadingIndicatorEl) loadingIndicatorEl.style.display = 'none';
            const statusMessage = e.name === 'AbortError' ?
                `Operação cancelada ao processar "${caminhoName}".` :
                `Erro ao processar "${caminhoName}": ${e.message || 'Erro desconhecido'}.`;
            activateLuckyFeature();
            setSpeedDialStatus(statusMessage, e.name !== 'AbortError');
            resetSpeedDialIcons();
            resetFavicon();
            hideCaminhoSidebar();
            endOperation(false);
        }
    }

    async function handleSearchInput() {
        if (!searchInputEl || !searchSuggestionsEl) return;
        const searchText = searchInputEl.value.trim().toLowerCase();

        // Revoke previous suggestion blobs
        for (const prevItem of previousSuggestionItems) {
            if (prevItem.blobUrl) {
                try { URL.revokeObjectURL(prevItem.blobUrl); } catch(e) { console.warn("Error revoking old suggestion blob", e); }
                prevItem.blobUrl = null;
                prevItem.loadSuccess = null;
            }
        }
        previousSuggestionItems = [];
        searchSuggestionsEl.innerHTML = '';

        if (searchText.length === 0) {
            searchSuggestionsEl.style.display = 'none';
            return;
        }

        const suggestionsMap = new Map();
        const currentSuggestionBlobsCreated = []; // Temp list for current suggestions
        let currentSearchOpSignal = null;

        if (rootDirectoryHandle) {
            searchInputEl.classList.add('loading-suggestions');
            if (window.suggestionAbortController) {
                window.suggestionAbortController.abort();
            }
            window.suggestionAbortController = new AbortController();
            currentSearchOpSignal = window.suggestionAbortController.signal;

            const suggestionProcessorFn = (fileHandle, relativePath, isCover, isOriginal, entryPrefix) => {
                if (currentSearchOpSignal?.aborted) throw new DOMException("Suggestion scan aborted", "AbortError");
                if (entryPrefix.toLowerCase().startsWith(searchText) && suggestionsMap.size < MAX_SEARCH_SUGGESTIONS && !suggestionsMap.has(entryPrefix)) {
                    suggestionsMap.set(entryPrefix, {
                        name: fileHandle.name,
                        fileHandle: fileHandle,
                        relativePath: relativePath,
                        isCoverFile: true,
                        isOriginal: false,
                        prefix: entryPrefix,
                        type: null,
                        loadSuccess: null,
                        blobUrl: null,
                        fileRef: null
                    });
                }
            };

            try {
                const capasDirHandle = await rootDirectoryHandle.getDirectoryHandle(CAPAS_FOLDER_NAME, { create: false });
                await consumeAsyncGenerator(scanDirectoryRecursive({
                    directoryHandle: capasDirHandle,
                    basePathParts: [CAPAS_FOLDER_NAME],
                    targetPrefix: null,
                    isCoverScan: true,
                    recursive: false,
                    signal: currentSearchOpSignal,
                    fileProcessorFn: suggestionProcessorFn,
                    entryCounter: { count: 0 }
                }));
            } catch (e) {
                if (e.name !== 'AbortError') {
                    console.warn("Error scanning .capas for suggestions:", e);
                }
            } finally {
                 searchInputEl.classList.remove('loading-suggestions');
            }

        } else if (mediaIndex && mediaIndex.size > 0) {
            for (const prefixFromIndex of mediaIndex.keys()) {
                if (prefixFromIndex.toLowerCase().startsWith(searchText) && !/^icon(\s*\d*)?$/i.test(prefixFromIndex)) {
                    const mediaData = mediaIndex.get(prefixFromIndex);
                    if (mediaData && mediaData.covers && mediaData.covers.length > 0) {
                        const coverItem = mediaData.covers[0];
                        if (coverItem && coverItem.prefix && !suggestionsMap.has(coverItem.prefix)) {
                            suggestionsMap.set(coverItem.prefix, { ...coverItem }); // Shallow copy for safety
                            if (suggestionsMap.size >= MAX_SEARCH_SUGGESTIONS) break;
                        }
                    }
                }
            }
        }

        if (currentSearchOpSignal?.aborted) {
            return;
        }

        if (suggestionsMap.size > 0) {
            const sortedPrefixes = Array.from(suggestionsMap.keys()).sort((a, b) => a.localeCompare(b));
            const fragment = document.createDocumentFragment();

            for (const prefixKey of sortedPrefixes) {
                const item = suggestionsMap.get(prefixKey);
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.title = `Mostrar mídia para "${item.prefix}"`;
                div.setAttribute('role', 'option');
                div.tabIndex = -1;

                const img = document.createElement('img');
                img.className = 'suggestion-thumbnail';
                img.alt = `Capa para ${item.prefix}`;
                img.loading = 'lazy'; // Added lazy loading
                div.appendChild(img);

                (async () => {
                    try {
                        // Use a fresh signal for each thumbnail load attempt if needed, or null for low priority.
                        // The suggestionAbortController is for the *scan*, not individual loads here.
                        const thumbnailLoadSignal = null;
                        if (!item.blobUrl || item.loadSuccess !== true) {
                            await loadBlobForItem(item, thumbnailLoadSignal);
                        }
                        if (item.blobUrl && item.loadSuccess === true) {
                            if (thumbnailLoadSignal?.aborted) { // Check signal before assigning src
                                URL.revokeObjectURL(item.blobUrl); item.blobUrl=null; item.loadSuccess=null; return;
                            }
                            img.src = item.blobUrl;
                            currentSuggestionBlobsCreated.push(item); // Add to list for later revocation
                            img.onload = () => img.classList.add('loaded');
                            img.onerror = () => { img.style.display = 'none'; console.warn(`Error rendering suggestion thumbnail for ${item.prefix}`); };
                        } else {
                            img.style.display = 'none';
                        }
                    } catch (thumbError) {
                        if (thumbError.name !== 'AbortError') {
                             console.warn(`Error in async load for suggestion thumbnail ${item.prefix}:`, thumbError);
                        }
                        img.style.display = 'none';
                    }
                })();

                const span = document.createElement('span');
                span.className = 'suggestion-text';
                span.textContent = item.prefix;
                div.appendChild(span);

                div.addEventListener('mousedown', (e) => { e.preventDefault(); handleSuggestionClick(item.prefix); });
                div.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSuggestionClick(item.prefix); });
                fragment.appendChild(div);
            }
            searchSuggestionsEl.appendChild(fragment);
            searchSuggestionsEl.style.display = 'block';
            previousSuggestionItems = currentSuggestionBlobsCreated; // Update the global list
        } else {
            searchSuggestionsEl.style.display = 'none';
        }
    }

    function handleSuggestionClick(p){
        // Revoke blobs from previous suggestions before loading new content
        for (const prevItem of previousSuggestionItems) {
            if (prevItem.blobUrl) {
                try { URL.revokeObjectURL(prevItem.blobUrl); } catch(e) { console.warn("Error revoking old suggestion blob", e); }
                prevItem.blobUrl = null;
                prevItem.loadSuccess = null;
            }
        }
        previousSuggestionItems = [];
        if(!searchInputEl||!searchSuggestionsEl||isLoading)return;
        searchSuggestionsEl.innerHTML='';
        searchSuggestionsEl.style.display='none';
        resetLuckyFeature();
        if(speedDialContainerEl) speedDialContainerEl.style.display = 'none';
        document.body.classList.remove('initial-load');
        hideCaminhoSidebar();
        displayGlobalMediaByPrefix(p);
    }

    function hideSuggestionsOnClickOutside(e){
        if(!searchInputEl||!searchSuggestionsEl)return;
        if(!e.target.closest('.search-container')&&!e.target.closest('#search-suggestions')){
            searchSuggestionsEl.innerHTML='';
            searchSuggestionsEl.style.display='none';
            // Revoke blobs when suggestions are hidden by clicking outside
            for (const prevItem of previousSuggestionItems) {
                if (prevItem.blobUrl) {
                    try { URL.revokeObjectURL(prevItem.blobUrl); } catch(err) { console.warn("Error revoking old suggestion blob", err); }
                    prevItem.blobUrl = null;
                    prevItem.loadSuccess = null;
                }
            }
            previousSuggestionItems = [];
        }
    }
    function loadSpeedDialConfig(){try{const s=localStorage.getItem(SPEED_DIAL_CONFIG_KEY);if(s){const p=JSON.parse(s);if(Array.isArray(p)&&p.every(i=>i&&typeof i.originalName==='string'&&typeof i.displayName==='string')){const c=new Set(p.map(i=>i.originalName)),d=new Set(CAMINHO_FOLDER_NAMES);if(c.size===d.size&&[...c].every(n=>d.has(n))){speedDialConfig=p;return}else{console.warn("Speed dial config mismatch with defaults. Resetting.");throw new Error("Config mismatch")}}else{console.warn("Invalid speed dial config found in localStorage. Resetting.")}}}catch(e){console.error("Failed to load or parse speed dial config. Resetting to default.",e)}speedDialConfig=CAMINHO_FOLDER_NAMES.map(n=>({originalName:n,displayName:n}));saveSpeedDialConfig()}
    function saveSpeedDialConfig(){try{localStorage.setItem(SPEED_DIAL_CONFIG_KEY,JSON.stringify(speedDialConfig))}catch(e){console.error("Failed to save speed dial config to localStorage:",e);setSpeedDialStatus("Não foi possível salvar a ordem/nomes dos itens.",!0)}}

    async function handleCaminhoSelection(event) {
        const targetItem = event.target.closest('.speed-dial-item');
        if (isLoading || !targetItem) return;

        // Check if a root folder (either legacy or new API) has been selected
        if (!rootDirectoryHandle && (!allSelectedFiles || allSelectedFiles.length === 0)) {
            if (!isLoading) setSpeedDialStatus("Selecione a pasta 'Nucleo' primeiro.", true);
            return;
        }

        const caminhoOriginalName = targetItem.dataset.caminho;
        if (!caminhoOriginalName) {
            console.error("Clicked speed dial item missing 'data-caminho' attribute.", targetItem);
            setSpeedDialStatus("Erro ao identificar o caminho selecionado.", true);
            return;
        }
        resetLuckyFeature();
        // processAndDisplayFilesForPath will now internally decide how to get files
        // based on rootDirectoryHandle's presence or allSelectedFiles.
        await processAndDisplayFilesForPath(caminhoOriginalName);
    }

    function renderSpeedDialItems(){if(!speedDialOptionsEl)return;speedDialOptionsEl.innerHTML='';const f=document.createDocumentFragment();speedDialConfig.forEach(c=>{const i=document.createElement('div');i.className='speed-dial-item';i.dataset.caminho=c.originalName;i.setAttribute('role','button');i.setAttribute('tabindex','0');i.draggable=!0;const o=document.createElement('div');o.className='icon-container';const m=document.createElement('img');m.className='speed-dial-icon';m.alt=`Ícone para ${c.displayName}`;m.src="";m.loading='lazy';const u=iconBlobUrls.get(c.originalName);if(u){m.src=u;m.classList.add('loaded')}else{i.classList.remove('icon-error')}o.appendChild(m);i.appendChild(o);const textEl=document.createElement('span');textEl.className='text';textEl.textContent=c.displayName;i.appendChild(textEl);const e=document.createElement('button');e.className='edit-btn';e.innerHTML='✎';e.title=`Renomear ${c.displayName}`;e.setAttribute('aria-label',`Renomear ${c.displayName}`);e.onclick=b=>{b.stopPropagation();b.preventDefault();handleRenameItem(c.originalName)};i.appendChild(e);i.addEventListener('click',handleCaminhoSelection);i.addEventListener('keydown',b=>{if(b.key==='Enter'||b.key===' '){b.preventDefault();handleCaminhoSelection(b)}});i.addEventListener('dragstart',handleDragStart);i.addEventListener('dragover',handleDragOver);i.addEventListener('dragleave',handleDragLeave);i.addEventListener('drop',handleDrop);i.addEventListener('dragend',handleDragEnd);f.appendChild(i)});speedDialOptionsEl.appendChild(f)}
    function handleRenameItem(o){const i=speedDialConfig.findIndex(t=>t.originalName===o);if(i===-1)return;const c=speedDialConfig[i].displayName,n=prompt(`Digite o novo nome para "${c}" (original: ${o}):`,c);if(n&&n.trim()!==''&&n.trim()!==c){speedDialConfig[i].displayName=n.trim();saveSpeedDialConfig();renderSpeedDialItems();setSpeedDialStatus(`"${c}" renomeado para "${n}".`,!1)}else if(n===null){setSpeedDialStatus("Renomeação cancelada.",!1)}else{setSpeedDialStatus("Nome inválido ou inalterado.",!0)}}
    function handleDragStart(e){const i=e.target.closest('.speed-dial-item');if(!i)return;draggedItemOriginalName=i.dataset.caminho;e.dataTransfer.setData('text/plain',draggedItemOriginalName);e.dataTransfer.effectAllowed='move';setTimeout(()=>i.classList.add('dragging'),0)}
    function handleDragOver(e){e.preventDefault();e.dataTransfer.dropEffect='move';const t=e.target.closest('.speed-dial-item');if(t&&t.dataset.caminho!==draggedItemOriginalName){t.classList.add('drag-over')}}
    function handleDragLeave(e){const t=e.target.closest('.speed-dial-item');if(t){t.classList.remove('drag-over')}}
    function handleDrop(e){e.preventDefault();const t=e.target.closest('.speed-dial-item');if(!t||t.dataset.caminho===draggedItemOriginalName||!draggedItemOriginalName){if(t)t.classList.remove('drag-over');return}const o=t.dataset.caminho;t.classList.remove('drag-over');const d=speedDialConfig.findIndex(i=>i.originalName===draggedItemOriginalName),g=speedDialConfig.findIndex(i=>i.originalName===o);if(d!==-1&&g!==-1){const[r]=speedDialConfig.splice(d,1);speedDialConfig.splice(g,0,r);saveSpeedDialConfig();renderSpeedDialItems();setSpeedDialStatus("Ordem atualizada.",!1)}draggedItemOriginalName=null}
    function handleDragEnd(e){const i=e.target.closest('.speed-dial-item');if(i){i.classList.remove('dragging')}document.querySelectorAll('.speed-dial-item.drag-over').forEach(el=>el.classList.remove('drag-over'));draggedItemOriginalName=null}

    let rootDirectoryHandle = null; // Global variable to store the directory handle

    async function handleDirectoryPickerSelection() {
        if (isLoading) return;
        const operationSignal = beginOperation();
        try {
            const handle = await window.showDirectoryPicker();
            rootDirectoryHandle = handle;
            rootDirName = handle.name;
            allSelectedFiles = []; // Not fetching all files upfront

            initialViewHistory = [];
            sessionViewedPrefixes.clear();
            mediaFiles.forEach(revokeItemResources);
            mediaFiles = [];
            mediaIndex.clear();

            cleanupUIState();
            resetSpeedDialIcons(); // Placeholder
            resetFavicon(); // Placeholder

            updateMainHeader('Random Media');
            if (controlsContainerEl) controlsContainerEl.style.display = 'none';
            if (selectNucleoButtonEl) selectNucleoButtonEl.style.display = 'none';
            if (document.getElementById('speed-dial-subtitle')) document.getElementById('speed-dial-subtitle').style.display = 'none';
            if (speedDialOptionsEl) speedDialOptionsEl.style.display = 'grid';

            setSpeedDialStatus(`Pasta "${rootDirName}" selecionada. Navegue para carregar os arquivos.`);
            document.body.classList.add('initial-load');
            if (speedDialOptionsEl) {
                speedDialOptionsEl.querySelectorAll('.speed-dial-item').forEach(t => {
                    t.style.pointerEvents = 'auto';
                    t.removeAttribute('aria-disabled');
                });
            }

            renderSpeedDialItems();
            loadSpeedDialConfig(); // Ensure this is called
            activateLuckyFeature(); // Placeholder, might need adjustment later
            await loadSpecificIcons(operationSignal);
            await loadSpecificFavicon(operationSignal);
            activateLuckyFeature(); // This will internally await getLuckyCoverCandidates

            hideCaminhoSidebar();
            endOperation(true);

        } catch (error) {
            if (error.name === 'AbortError') {
                setSpeedDialStatus("Seleção de pasta cancelada.", false);
            } else {
                console.error("Erro ao selecionar pasta com File System Access API:", error);
                setSpeedDialStatus(`Erro ao selecionar pasta: ${error.message}`, true);
            }
            rootDirectoryHandle = null;
            rootDirName = '';
            allSelectedFiles = null;
            if (selectNucleoButtonEl) selectNucleoButtonEl.style.display = 'inline-block';
            if (speedDialOptionsEl) speedDialOptionsEl.style.display = 'none';
            document.body.classList.add('initial-load');
            if (document.getElementById('speed-dial-subtitle')) document.getElementById('speed-dial-subtitle').style.display = 'block';
            resetSpeedDialIcons();
            resetFavicon();
            activateLuckyFeature();
            endOperation(false);
        }
    }

    async function handleFolderSelectionLegacy(e){if(isLoading)return;const f=e.target.files,i=e.target;if(!f||f.length===0){setSpeedDialStatus("Nenhuma pasta selecionada ou seleção cancelada.",!1);allSelectedFiles=null;rootDirName='';if(selectNucleoButtonEl)selectNucleoButtonEl.style.display='inline-block';if(speedDialOptionsEl)speedDialOptionsEl.style.display='none';resetSpeedDialIcons();resetFavicon();resetLuckyFeature();document.body.classList.add('initial-load');if(controlsContainerEl) controlsContainerEl.style.display = 'none';i.value=null;hideCaminhoSidebar(); updateMainHeader('Random Media'); return}let r="Seleção",p=!0;if(f[0]?.webkitRelativePath){const F=f[0].webkitRelativePath.replace(/^\.\//,''),s=F.split('/')[0];if(s){r=s;for(let t=1;t<f.length;t++){const l=f[t].webkitRelativePath?.replace(/^\.\//,'');if(!l||!l.startsWith(r+'/')){p=!1;r="Seleção";console.warn("Inconsistent paths detected. Not a single root folder selection.");break}}}}else{p=!1}allSelectedFiles=f;rootDirName=r;initialViewHistory=[];sessionViewedPrefixes.clear();mediaFiles.forEach(revokeItemResources);mediaFiles=[];mediaIndex.clear();cleanupUIState();resetSpeedDialIcons();resetFavicon();/* resetLuckyFeature() is called within activateLuckyFeature */; updateMainHeader('Random Media'); if(controlsContainerEl)controlsContainerEl.style.display='none';if(selectNucleoButtonEl)selectNucleoButtonEl.style.display='none';if(document.getElementById('speed-dial-subtitle'))document.getElementById('speed-dial-subtitle').style.display='none';if(speedDialOptionsEl)speedDialOptionsEl.style.display='grid';setSpeedDialStatus(`Pasta "${rootDirName}" carregada (${f.length} arquivos). Carregando recursos...`);document.body.classList.add('initial-load');if(speedDialOptionsEl){speedDialOptionsEl.querySelectorAll('.speed-dial-item').forEach(t=>{t.style.pointerEvents='auto';t.removeAttribute('aria-disabled')})}i.value=null;renderSpeedDialItems();await loadSpecificIcons(allSelectedFiles);await loadSpecificFavicon(allSelectedFiles);activateLuckyFeature();hideCaminhoSidebar();}
    async function handleReturnToSpeedDialClick(){if(isLoading)return;const s=beginOperation();try{
        updateMainHeader('Random Media'); // Reset header
        cleanupUIState();if(mediaContainerEl)mediaContainerEl.style.display='none';if(controlsContainerEl)controlsContainerEl.style.display='none';if(speedDialContainerEl)speedDialContainerEl.style.display='flex';document.body.classList.add('initial-load');setSpeedDialStatus("Selecione um Caminho ou carregue uma nova pasta 'Nucleo'.",!1);mediaFiles.forEach(revokeItemResources);mediaFiles=[];mediaIndex.clear();initialViewHistory=[];sessionViewedPrefixes.clear();hideCaminhoSidebar();endOperation(!0);activateLuckyFeature();}catch(e){if(e.name!=='AbortError'){console.error("Error returning to speed dial:",e);setSpeedDialStatus("Erro ao retornar ao início. Verifique o console.",!0)}endOperation(!1); return;}
    }
    function handleGlobalKeyDown(e){if(e.key==='Escape'){if(fullscreenMediaEl&&fullscreenMediaEl.style.display==='flex'){closeFullscreenMedia()} else if (caminhoSidebarEl && caminhoSidebarEl.classList.contains('visible')) {hideCaminhoSidebar();}}}
    document.addEventListener('DOMContentLoaded',()=>{coverOverlayBlur=document.getElementById('cover-overlay-blur');coverOverlay=document.getElementById('cover-overlay');mediaContainerEl=document.getElementById('media-container');loadingIndicatorEl=document.getElementById('loading-indicator');newMediaButton=document.getElementById('new-media');themeToggleButton=document.getElementById('theme-toggle-button');speedDialContainerEl=document.getElementById('speed-dial-container');selectNucleoButtonEl=document.getElementById('select-nucleo-folder');speedDialOptionsEl=document.getElementById('speed-dial-options');speedDialStatusEl=document.getElementById('speed-dial-status');faviconElement=document.getElementById('favicon');folderInputEl=document.getElementById('folder-input');fullscreenMediaEl=document.getElementById('fullscreen-media');fullscreenImgEl=document.getElementById('fullscreen-img');fullscreenVideoEl=document.getElementById('fullscreen-video');rotateButtonEl=document.getElementById('rotate-button');searchInputEl=document.getElementById('search-input');searchSuggestionsEl=document.getElementById('search-suggestions');returnToSpeedDialButton=document.getElementById('return-to-speed-dial');luckyFeatureContainerEl=document.getElementById('lucky-feature-container');luckyImageWrapperEl=document.getElementById('lucky-image-wrapper');luckyImageEl=document.getElementById('lucky-image');luckyImageTextEl=document.getElementById('lucky-image-text');controlsContainerEl = document.querySelector('.controls-container');
    mainHeaderTitleEl = document.getElementById('main-header-title'); // Initialize mainHeaderTitleEl
    caminhoSidebarEl = document.getElementById('caminho-sidebar');
    caminhoSidebarListEl = document.getElementById('caminho-sidebar-list');
    caminhoSidebarTitleEl = document.getElementById('caminho-sidebar-title');
    caminhoSidebarCloseBtnEl = document.getElementById('caminho-sidebar-close-btn');

    const c={coverOverlayBlur,coverOverlay,mediaContainerEl,loadingIndicatorEl,newMediaButton,themeToggleButton,speedDialContainerEl,selectNucleoButtonEl,speedDialOptionsEl,speedDialStatusEl,faviconElement,folderInputEl,fullscreenMediaEl,fullscreenImgEl,fullscreenVideoEl,rotateButtonEl,searchInputEl,searchSuggestionsEl,returnToSpeedDialButton,luckyFeatureContainerEl,luckyImageWrapperEl,luckyImageEl,luckyImageTextEl,controlsContainerEl,caminhoSidebarEl,caminhoSidebarListEl,caminhoSidebarTitleEl,caminhoSidebarCloseBtnEl, mainHeaderTitleEl};const m=Object.entries(c).filter(([_,el])=>!el);if(m.length>0){const e=`Application Error! Required elements not found: ${m.map(([n,_])=>n).join(', ')}`;console.error(e);try{document.body.innerHTML=`<h1 style='color:red; text-align:center;'>Application Error!</h1><p style='text-align:center;'>Required elements not found: ${m.map(([n,_])=>n).join(', ')}</p>`}catch(E){}return}
    updateMainHeader('Random Media'); // Set initial header
    if(controlsContainerEl)controlsContainerEl.style.display='none';loadSpeedDialConfig();renderSpeedDialItems();resetLuckyFeature();function u(){themeToggleButton.textContent=document.body.classList.contains('light-theme')?'Modo Escuro':'Modo Claro'}u();themeToggleButton.addEventListener('click',()=>{document.body.classList.toggle('light-theme');const t=document.body.classList.contains('light-theme')?'light':'dark';try{localStorage.setItem(THEME_KEY,t)}catch(n){console.error("Failed to save theme preference:",n)}u()});
    selectNucleoButtonEl.addEventListener('click', () => {
        if (isLoading) return;

        // Common reset logic before attempting any selection
        initialViewHistory = [];
        sessionViewedPrefixes.clear();
        mediaFiles.forEach(revokeItemResources);
        mediaFiles = [];
        mediaIndex.clear();
        allSelectedFiles = null;
        rootDirName = '';
        rootDirectoryHandle = null; // Reset handle

        cleanupUIState();
        resetSpeedDialIcons();
        resetFavicon();
        resetLuckyFeature();
        updateMainHeader('Random Media');
        document.body.classList.add('initial-load');
        if (mediaContainerEl) mediaContainerEl.style.display = 'none';
        if (controlsContainerEl) controlsContainerEl.style.display = 'none';
        if (document.getElementById('speed-dial-subtitle')) document.getElementById('speed-dial-subtitle').style.display = 'block';
        if (speedDialOptionsEl) speedDialOptionsEl.style.display = 'none';
        renderSpeedDialItems(); // Render empty items or hide them appropriately

        setSpeedDialStatus("Aguardando seleção da pasta 'Nucleo'...");

        if ('showDirectoryPicker' in window) {
            handleDirectoryPickerSelection();
        } else {
            if (folderInputEl) {
                folderInputEl.click();
            } else {
                setSpeedDialStatus("Erro: Input de fallback não encontrado.", true);
                console.error("Legacy folder input not found.");
            }
        }
    });
    folderInputEl.addEventListener('change',handleFolderSelectionLegacy);if(returnToSpeedDialButton)returnToSpeedDialButton.addEventListener('click',handleReturnToSpeedDialClick);if(luckyImageWrapperEl)luckyImageWrapperEl.addEventListener('click',handleLuckyImageClick);
    if(caminhoSidebarCloseBtnEl) caminhoSidebarCloseBtnEl.addEventListener('click', hideCaminhoSidebar);
    newMediaButton.addEventListener('click',async()=>{if(isLoading||!allSelectedFiles||mediaFiles.length===0)return;const s=beginOperation();try{
    updateMainHeader('Random Media'); // Reset header
    resetLuckyFeature();if(speedDialContainerEl) speedDialContainerEl.style.display = 'none'; document.body.classList.remove('initial-load'); cleanupUIState();const n=mediaFiles.filter(i=>!i.isCoverFile);if(n.length>0){if(mediaContainerEl)mediaContainerEl.style.display='block';if(controlsContainerEl)controlsContainerEl.style.display='flex';await displayMedia(getRandomInitialMedia(n,MAX_INITIAL_ITEMS),s,!0);
    const currentPathName = speedDialConfig.find(cfg => {
        if (mediaFiles.length > 0 && mediaFiles[0].relativePath) {
            const parts = mediaFiles[0].relativePath.split('/');
            const basePath = rootDirName ? `${rootDirName}/` : '';
            if (parts.length > (rootDirName ? 1:0) && mediaFiles[0].relativePath.startsWith(basePath)) {
                 const caminhoPart = parts[rootDirName ? 1 : 0];
                 return cfg.originalName === caminhoPart;
            }
        }
        return false;
    })?.originalName;

    if (currentPathName) {
        const uniquePrefixesInPath = Array.from(new Set(n.map(file => file.prefix).filter(Boolean))).sort((a,b) => a.localeCompare(b));
        showCaminhoSidebar(currentPathName, uniquePrefixesInPath);
    } else {
        hideCaminhoSidebar(); 
    }
    
    }else{const e="text-align: center; width: 100%; column-span: all; padding: 20px 0;";if(mediaContainerEl){mediaContainerEl.innerHTML=`<p style="${e}">Nada a exibir (sem mídia regular neste Caminho).</p>`;mediaContainerEl.style.display='block'} if(controlsContainerEl)controlsContainerEl.style.display='flex'; hideCaminhoSidebar();}endOperation(!0)}catch(r){if(r.name!=='AbortError'){console.error("Error displaying new random media:",r);const e="color:var(--error-text); text-align: center; width: 100%; column-span: all; padding: 20px 0;";if(mediaContainerEl){mediaContainerEl.innerHTML=`<p style="${e}">Erro ao exibir nova mídia: ${r.message||'Erro desconhecido'}</p>`;mediaContainerEl.style.display='block'}endOperation(!1)}else{console.log("Display new media cancelled.");endOperation(!1)}}});searchInputEl.addEventListener('input',handleSearchInput);searchInputEl.addEventListener('blur',e=>{setTimeout(()=>{if(!searchSuggestionsEl||!document.activeElement||!document.activeElement.closest('#search-suggestions')){if(searchSuggestionsEl){searchSuggestionsEl.innerHTML='';searchSuggestionsEl.style.display='none'}}},150)});document.addEventListener('click',hideSuggestionsOnClickOutside);searchInputEl.setAttribute('autocomplete','off');searchInputEl.disabled=!0;searchInputEl.addEventListener('keydown',e=>{if(!searchSuggestionsEl||searchSuggestionsEl.style.display==='none'||searchSuggestionsEl.children.length===0)return;const s=Array.from(searchSuggestionsEl.children);let a=s.findIndex(i=>i.classList.contains('active'));if(e.key==='ArrowDown'){e.preventDefault();s[a]?.classList.remove('active');a=(a+1)%s.length;s[a].classList.add('active');s[a].scrollIntoView({block:'nearest'})}else if(e.key==='ArrowUp'){e.preventDefault();s[a]?.classList.remove('active');a=(a-1+s.length)%s.length;s[a].classList.add('active');s[a].scrollIntoView({block:'nearest'})}else if(e.key==='Enter'){if(a>-1){e.preventDefault();s[a].dispatchEvent(new MouseEvent('mousedown'))}}else if(e.key==='Escape'){searchSuggestionsEl.innerHTML='';searchSuggestionsEl.style.display='none'}});document.addEventListener('keydown',handleGlobalKeyDown);setSpeedDialStatus("Por favor, selecione a pasta 'Nucleo'.")});
</script>
</body>
</html>

